<app>
  <p><i18n>粒子に命が宿る世界をのんびり眺めるサイトです。</i18n><br class="weak" />
     <i18n>飽きたら「次のワールドを生成」を押して下さい。</i18n></p>

  <div id="fps" style="text-align:right;max-width:600px"></div>
  <div class="columns is-desktop">
    <div class="column is-narrow" style="line-height:1;position:relative;">
      
      <particles-display width="600" height="600" 
          on-restart={onDisplayRequestRestart} intf={displayIntf}></particles-display><br>
      
      <color-scale-editor width="600" height="40" 
          on-update={onColorScaleEditorUpdate} intf={colorScaleEditorIntf}></color-scale-editor>
      
      <div class="top-buttons">
        <a class="button is-info is-small" id="new-world" onclick={onNewWorldClick}>
            <i18n>次のワールドを生成</i18n></a>
        <a class="button is-info is-small" id="copy-url" onclick={onCopyUrlClick}>
            <i18n>このワールドをシェア</i18n>&nbsp;&nbsp;&nbsp;
            <span class="icon"><ion-icon name="share-social"></ion-icon></span></a>
        <div class="block" id="copy-url-message">
          <span class="tag is-success">
            <i18n>このワールドへの URL をコピーしました</i18n>
          </span>
        </div>
        <a class="button is-info is-small" id="full-screen" onclick={onFullScreenClick}>
            <i18n>全画面</i18n> &nbsp; 
            <span class="icon"><ion-icon name="expand"></ion-icon></span></a>
        <div class="block" id="full-screen-message">
          <span class="tag is-success">
            <i18n>画面外のダブルタップで次のワールドを生成できます</i18n>
          </span>
        </div>
      </div>

      <plcontrols 
        intf={controlsIntf}
        on-show-editor={onShowEditorClick} 
        on-record={onRecordClick} 
        on-restart={onRestartFromControls}
        on-pause={onPauseClick}
        on-update={onControlsUpdate}
        on-help={helpPopupIntf.show}
      ></plcontrols>
    </div>

    <div class="column is-narrow" id="world-editor">
      <interaction-editor width="600" 
        intf={intEditorIntf}
      ></interaction-editor>
    </div>

  </div>

  <video-holder intf={videoHolderIntf}></video-holder>

  <div class="content">
      <help-popup intf={helpPopupIntf} messages={helpContents}>
        <ul>
          <li each={message in messages}><raw html={message}></raw></li>
        </ul>
      </help-popup>
  </div>

  <style type="scss">
    .top-buttons {
      position: relative;
      margin-bottom:20px;
      margin-top:4px;
      overflow-x: clip;
      max-width: var(--100vw);
      white-space: nowrap;
      .button {
        margin-right: 5px;
      }
    }
    @media screen and (max-width: 420px) {
      .top-buttons {
        margin-left: -0.75rem;
        margin-right: -0.75rem;
      }
    }
    #copy-url-message {
      display: block;
      position: absolute;
      top: -40px;
      left: 70px;
      
    }

    #copy-url-message {
      display: none;
    }

    #full-screen-message {
      display: none;
      position:absolute;
      top: -50px;
      left: 30px;
    }

    #world-editor {
      display: none;
    }

    :host.world-editor-shown #world-editor {
      display: block;
    }

    :host.world-editor-shown plcontrols {
      max-width: 600px;
      display: block;
    }

  </style>

  <script>
    import { CanvasRenderer } from '../canvas-renderer.js'
    import { interactionSets } from '../interaction-sets.js'
    import { ColorScale, colorScaleList } from "../color-scale.js"
    import { ParticleLife } from '../particle-life.js'
    import { XorShift128 } from '../xorshift128.js'
    import helpContents from '../help-contents.js'
    export default {
      onBeforeMount() {
        // コンポーネントを構成する

        this.world = null;
        this.colorFunc = null;

        this.helpContents = helpContents;

        this.displayIntf = {
          world: () => this.world,
          colorFunc: () => this.colorFunc,
          repelX: NaN,
          repelY: NaN,
          update: null,
          render: null,
          canvas: null
        }

        this.helpPopupIntf = {
          show: null,
          helpDisplayTarget: "help-list"
        }
        
        this.colorScaleEditorIntf = {
          update: null,
          colorScaleList: colorScaleList,
        }

        this.intEditorIntf = {
          update: null,
          intColorFunc: (()=>{
                const colorScale = new ColorScale([  // heat
                  [0/4,   0, 255, 255 ],
                  [1/4,   0,   0, 192 ],
                  [2/4,   0,   0,   0 ],
                  [3/4, 192,   0,   0 ],
                  [4/4, 255, 255,   0 ],
                ]);
                return (x)=> colorScale.color(x);
              })(),
        }

        this.controlsIntf = {
          getWorldOptions: null,
          updatePaletteSetting: null,
          update: null,
          getWorldURL: null,
          recommendations: this.props.recommendations,
        }

        this.videoHolderIntf = {
          setBlob: null
        }
      },

      onMounted() {
        this.controlsIntf.update();
        this.colorScaleEditorIntf.update();

        this.renderer = new CanvasRenderer(
          this.displayIntf.canvas(), 
          this.render, 
          (blob)=> this.videoHolderIntf.setBlob(blob, 
              '?' + this.controlsIntf.getWorldURL().split('?')[1]) // search 部分
        );

        this.update();
        this.restart();
      },

      displayFps(fps) {
        const elemFps = document.getElementById('fps');
        elemFps.innerText = `${String(fps).slice(0, 4)} fps`;
      },

      onControlsUpdate(e) {
        const options = e.detail;
        if(this.root.classList.contains('world-editor-shown')) {
          delete options.perturb;
        }
        if(this.world) this.world.update(options);
        this.colorScaleEditorIntf.update(options.paletteSetting);
        this.displayIntf.update({tail: options.tail, screen: options.screen, particleSize: options.particleSize});
        if(this.renderer) this.renderer.maxFps = options.maxfps;
        document.querySelector('color-scale-editor').style.display = options.showPalette ? 'block' : 'none';
      },

      onColorScaleEditorUpdate(e) {
        this.colorFunc = e.detail.colorFunc;
        if(this.intEditorIntf.update) 
          this.intEditorIntf.update();
        this.displayIntf.render();
        if(this.controlsIntf.updatePaletteSetting)
          this.controlsIntf.updatePaletteSetting(e.detail);
      },

      render() {
        this.world.interactParticles();
        this.world.repelParticles(this.displayIntf.repelX, this.displayIntf.repelY);
        this.world.moveParticles();
        this.displayIntf.render();
        this.displayFps(this.renderer.fps);
      },

      createWorld(randomize=false, fullScreen=false) {
        options = this.controlsIntf.getWorldOptions(randomize, fullScreen);
        if(this.root.classList.contains('world-editor-shown')) {
          delete options.perturb;
        }
        if(!this.world) {
          this.world = new ParticleLife(options, new XorShift128(options.world_seed));
        } else {
          this.world.update(options, new XorShift128(options.world_seed));
        }

        // 相互作用を指定する
        interactionSets[options.intset](this.world.interaction, new XorShift128(options.interact_seed));

        // 粒子種に偏りを持たせるための確率分布の累積を作る
        let distribution = new PLSpeciesDistribution(this.world.nspecies, this.world.rand);

        // 粒子の初期配置を決める
        this.world.setupParticles( (i, j) => [
          // 本当は world.nlattice で割るべきなのだけれど互換性のためこのまま
          distribution.species(this.world.rand.next()),
          i / (this.world.nlattice - 1) - 0.5 + 0.2 * (this.world.rand.next() - 0.5),  // x
          j / (this.world.nlattice - 1) - 0.5 + 0.2 * (this.world.rand.next() - 0.5),  // y
          0, 0  // vx, vy
        ]);
      },

      restart(randomize = false, fullScreen = false) {
        if(this.world) this.world.recreating = true;
        try {
          this.createWorld(randomize, fullScreen);
        } finally {
          this.world.recreating = false;
        }
        this.intEditorIntf.update({
          world: this.world,
          colorFunc: (x) => this.colorFunc(x)
        });
        this.renderer.start();
      },

      onPauseClick(e) {
        if(e.detail.pause) {
          this.renderer.stop();
        } else {
          this.renderer.start();
        }
      },

      onRecordClick(e) {
        if(e.detail.recording) {
          this.renderer.startRecording();
        } else {
          this.renderer.stopRecording();
        }
      },

      onRestartFromControls(e) {
        this.renderer.stop();
        const {randomize, fullScreen} = e.detail;
        this.restart(randomize, fullScreen);
      },

      onNewWorldClick() {
        this.renderer.stop();
        this.restart(true);
      },

      onShowEditorClick() {
        this.root.classList.toggle('world-editor-shown');
      },

      onFullScreenClick() {
        const style = document.getElementById("full-screen-message").style;
        style.display = "block"
        setTimeout(()=> {
            style.display = "none";
            this.controlsIntf.update({screen: 'F'}); 
        }, 1000);
      },

      onCopyUrlClick() {
        navigator.clipboard.writeText(this.controlsIntf.getWorldURL());
        const style = document.getElementById("copy-url-message").style;
        setTimeout(()=> style.display = "block", 100);
        setTimeout(()=> style.display = "none", 1600);
      },

      onDisplayRequestRestart() {
        this.restart(true, true);
      },
    }
  </script>

</app>
