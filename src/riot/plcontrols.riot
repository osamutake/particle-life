p<!-----------------------------------------------------------------

  ワールド生成パラメータを制御するためのコントロール
  css は bulma を使用

  props = {
  }

  this.state = {
    pause: false,
    recording: false,
    interact_seed: 2**53 * Math.random(),
    world_seed: 2**53 * Math.random(),
    nspecies: 6,
    nlattice: 30,
    scale: 1,
    tail: 0,
    maxfps: 20,
    intset: "",
  };

  EVENTS: どれも e.detail には state が入る
    update
    restart
    pause
    record

----------------------------------------------------------------->

<plcontrols>
  <div class="columns">
    <div class="column is-narrow field">
      <label for="recommendation" class="label">ワールド設定</label>
      <div class="select">
        <select id="recommendation" value="" onchange={ recommendationChange }>
          <option value="" >URLで</option>
          <option  each={ recommendation in recommendations } key={recommendation[1]} value={recommendation[1]}>{recommendation[0]}</option>
        </select>
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="interact_seed" class="label">描画制御</label>
      <div class="field has-addons">
        <p class="control">
          <button class="button" onclick={ ()=> dispatchEvent("restart", state) } id="replay" title="始めに戻ってリプレイ">
            <span class="icon is-small"><ion-icon name="play-skip-back"></ion-icon></span>
          </button>
        </p>
        <p class="control">
          <button id="pause" class={ state.pause ? "button is-danger" : "button" }
                  onclick={ ()=> { update({"pause": !state.pause }); dispatchEvent("pause", state); } } title="ポーズ／再開">
            <span class="icon is-small"><ion-icon name={ state.pause ? "play" : "pause" }></ion-icon></span>
          </button>
        </p>
        <p class="control">
          <button id="recording" class={ state.recording ? "button is-danger" : "button" } 
                  onclick={ ()=>{ update({"recording": !state.recording }); dispatchEvent("record", state); } } title="webm に録画">
            <span class="icon is-small"><ion-icon name={ state.recording ? "stop" : "ellipse" }></ion-icon></span>
          </button>
        </p>
        <p class="control">
          <button id="palette" class={ state.showPalette ? "button is-dark" : "button" } 
                  onclick={ ()=>{ update({"showPalette": !state.showPalette }) } } title="カラーパレット編集">
            <span class="icon is-small"><ion-icon name="color-palette"></ion-icon></span>
          </button>
        </p>
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="particleSize" class="label">粒径</label>
      <div class="control">
        <input class="input" id="particleSize" type="number"  value={state.particleSize} size="1" onchange={ editorChanged } /> 
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="screen" class="label">画面 &nbsp; <span class="icon is-clickable" onclick={ ()=> update({screen: "F"}) }><ion-icon name="expand"></ion-icon></span></label>
      <div class="select">
        <select id="screen" value={state.screen} onchange={ editorChanged }>
          <option value="XS">XS</option>
          <option value="S">S</option>
          <option value="M">M</option>
          <option value="L">L</option>
          <option value="F">Full</option>
        </select>
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="maxfps" class="label">最大fps</label>
      <div class="control">
        <input class="input" id="maxfps" type="number"  value={state.maxfps} size="1" onchange={ editorChanged } /> 
      </div>
    </div>
    <div class="column is-narrow field">
      <label class="label">使い方</label>
      <div class="control">
        <button class="button is-info" onclick={ ()=> document.querySelector('help-popup').show() }>
          <span class="icon is-small"><ion-icon name="help"></ion-icon></span>
        </button>
      </div>
    </div>
  </div>
  <div style={`display: ${ $('#recommendation').value=='?' ? 'block' : 'none' }`}>

  <div class="columns">
    <div class="column is-narrow field">
      <label for="intset" class="label">相互作用セット</label>
      <div class="select">
        <select id="intset" value={state.intset} onchange={ editorChanged }>
          <option value="">デフォルト</option>
          <option value="A">多粒子種補正A</option>
          <option value="B">多粒子種補正B</option>
        </select>
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="interact_seed" class="label">相互作用シード</label>
      <div class="field has-addons">
        <div class="control">
          <input class="input" id="interact_seed" type="number" value={ state.interact_seed } size="8">
        </div>
        <div class="control">
          <a class="button is-info" onclick={ regenerateInteractionSeed }>
            <span class="icon is-small"><ion-icon name="refresh"></ion-icon></span>
          </a>
        </div>
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="world_seed" class="label">粒子配置シード</label>
      <div class="field has-addons">
        <div class="control">
          <input class="input" id="world_seed" type="number" value={ state.world_seed } size="8">
        </div>
        <div class="control">
          <a class="button is-info" onclick={ regenerateWorldSeed }>
            <span class="icon is-small"><ion-icon name="refresh"></ion-icon></span>
          </a>
        </div>
      </div>
    </div>
  </div>
  <div class="columns">
    <div class="column is-narrow field">
      <label for="nspecies" class="label">粒子種数</label>
      <div class="control">
        <input class="input" id="nspecies" type="number" value={state.nspecies} size="2" onchange={ editorChanged } />
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="nparticles" class="label">√粒子数</label>
      <div class="control">
        <input class="input" id="nlattice" type="number" value={state.nlattice} size="2" onchange={ editorChanged } />
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="scale" class="label">スケール</label>
      <div class="control">
        <input class="input" id="scale" type="number"  value={state.scale} size="2" onchange={ editorChanged } />
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="step" class="label">計算ステップ</label>
      <div class="control">
        <input class="input" id="step" type="number"  value={state.step} size="2" onchange={ editorChanged } /> 
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="tail" class="label">尾の長さ</label>
      <div class="control">
        <input class="input" id="tail" type="number"  value={state.tail} size="2" onchange={ editorChanged } /> 
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="perterb" class="label">揺動</label>
      <div class="control">
        <input id="perterb" type="checkbox" checked={state.perterb != 0} onchange={ editorChanged } /> 
      </div>
    </div>
  </div>

  <a class="button is-info is-small" id="show-editor">パラメータエディタを表示/非表示</a>
  </div>

  <div class="columns" style="display:none">
    <div class="column is-narrow field">
      <label for="webgl" class="label">WebGL</label>
      <div class="control">
        <input type="checkbox" id="webgl" checked="checked"/> 
      </div>
    </div>
  </div>


  <style type="scss">
    :host span.icon {
      margin: 0px -2px !important;
    }
    .columns {
      display: flex;
      max-width: var(--100vw);
      flex-wrap: wrap;
      @media screen and (min-width: 420px) and (max-width: 640px) {
        padding-left: 0.5em;
      }
    }
    .is-narrow {
      flex: none;
      width: unset;
    }
    .column.is-narrow.field {
      padding: 0.5rem;
    }
  </style>

  <script>
    export default {
      onMounted() {
        util.implementEventTarget(this);

        this.default_state = {
          pause: false,
          recording: false,
          interact_seed: 2**53 * Math.random(),
          world_seed: 2**53 * Math.random(),
          nspecies: 6,
          nlattice: 30,
          scale: 3,
          tail: 0,
          maxfps: 60,
          step: 1,
          intset: "",
          perterb: 0.001,
          screen: "S",
          particleSize: 4,
        };
        
        this.state = Object.assign({}, this.default_state);

        this.recommendations.push(...this.props.recommendations);

        if(location.search) {
          this.setParameters(location.search);
        } else {
          let recom = this.recommendations.find((rec)=> rec.length > 2)[1];
          this.setParameters(recom);
          this.$('#recommendation').value = recom;
        }

        this.flashControl(this.$('#recommendation'), '#ff3');

        const canvas = document.getElementById("particles-display");
        canvas.addEventListener('fullscreenchange', (e) => {
          if(!document.fullscreenElement) {
            // フルスクリーンが終了した
            document.removeEventListener('keydown', this.keydownWhileFullScreen);
            this.state.screen = this.lastScreen;
            this.update();
          }
        });
      },

      flashing: false,

      async flashControl(control, color) {
        if(this.flashing) return;

        this.flashing = true;
        const original = control.style.backgroundColor;
        for(let i = 0; i < 5; i++) {
          control.style.backgroundColor = color;
          await util.sleep(400);
          control.style.backgroundColor = original;
          await util.sleep(400);
        }
        this.flashing = false;
      },

      validatedState(randomize) {
        if(randomize) {
          this.update({ 
              interact_seed: 2**53 * Math.random(),
              world_seed:    2**53 * Math.random()
          });
        }

        let result = Object.assign({}, this.state);
        for(let k of Object.keys(this.state.validation.errors.errors)) {
          delete result[k];
        }
        delete result.validation;
        return result;
      },

      recommendations: [['自分で', '?']],

      recommendationChange(e) {
        if(e.target.value != '?' && e.target.value) {
          let params = this.parseParameters(e.target.value);
          params.world_seed = 2**53 * Math.random();
          params.interact_seed = 2**53 * Math.random();
          this.update(params);
          this.dispatchEvent("restart", this.state);
        } else {
          this.update();
        }

        this.flashControl(document.getElementById('new-world'), '#880');
      },

      editorChanged(e) {
        let {id, value} = e.target;
        if(e.target.id == "perterb") {
          this.update({perterb: (e.target.checked ? 0.001 : 0)});
        } else
        if(e.target.id == "scale") {
          this.update({
            scale: value,
            step: Math.round(this.state.step * this.state.scale / value * 1000)/1000
          });
        } else {
          this.update(Object.fromEntries([[id, value]]));
        }
        if(["nspecies", "nlattice", "scale", "intset", "step"].includes(e.target.id))
          this.dispatchEvent("restart", this.state);
      },

      regenerateInteractionSeed() {
        this.update({ interact_seed: 2**53 * Math.random() });
        this.dispatchEvent("restart", this.state);
      },
      regenerateWorldSeed() {
        this.update({ world_seed: 2**53 * Math.random() });
        this.dispatchEvent("restart", this.state);
      },

      onBeforeUpdate(props, state) {
        // allows recalculation of context data before the update
        const rule = {
          pause: 'boolean',
          recording: 'boolean',
          interact_seed: ['required', 'integer', 'min:1'],
          world_seed: ['required', 'integer', 'min:1'],
          nspecies: ['required', 'integer', 'between:1,200'],
          nlattice: ['required', 'integer', 'between:5,300'],
          scale: ['required', 'numeric', 'between:0.5,20'],
          tail: ['required', 'numeric', 'min:0'],
          maxfps: ['required', 'numeric', 'between:0,1000'],
          intset: ['regex:/^[A-Z]?$/'],
          screen: ['required'],
          particleSize: ['required', 'numeric', 'between:0,127.5'],
        };

        state.validation = new Validator(state, rule);
        state.validation.passes();  // check!

        for(let id of Object.keys(rule)) {
          if(state.validation.errors.errors[id]) {
            this.$('#'+id).classList.add('is-danger');
            if(this.lastState && this.lastState[id])
              this.state[id] = this.lastState[id]; // 直前の値に戻す
          } else {
            this.$('#'+id).classList.remove('is-danger');
          }
        }
      },
      
      onUpdated(props, state) {
          this.dispatchEvent("update", this.state);

          if(state.screen == "F") {
            this.lastScreen = !this.lastState ? "S" :
                              this.lastState.screen == "F" ? (this.lastScreen || "S") : this.lastState.screen;
            const canvas = document.getElementById("particles-display");
            canvas.requestFullscreen();
            if(!this.keydownWhileFullScreen) {
              this.keydownWhileFullScreen = (e) => {
                if(e.key == 'n' || e.key == 'N') {
                  this.update({ 
                    interact_seed: 2**53 * Math.random(),
                    world_seed: 2**53 * Math.random()
                  });
                  this.dispatchEvent("restart", this.state);
                } else
                if(e.key == ' ') {
                  this.$('#pause').click();
                }
              };
            }
            document.addEventListener('keydown', this.keydownWhileFullScreen);
          }

          // 直前の設定を取っておく
          this.lastState = Object.assign({}, this.state);
          this.updateURL();
      },
      
      updateURL() {
          history.replaceState({}, '', this.encodeParameters());
      },
      
      num2char(n) {
        const offset = n < 10          ? 0x30           :     // '0'
                       n < 10 + 26     ? 0x41 - 10      :     // 'A'
                       n < 10 + 26 * 2 ? 0x61 - 10 - 26 : -1; // 'a'

        if(offset < 0) return "?";
        
        return String.fromCharCode(offset + n);
      },
      
      char2num(c) {
        if(c == '?') return NaN;
        c = c.charAt(0);
        let n = c.charCodeAt(0);
        return ('a' <= c && c <= 'z') ? n - 0x61 + 10 + 26 :
               ('A' <= c && c <= 'Z') ? n - 0x41 + 10      :
               ('0' <= c && c <= '9') ? n - 0x30           : NaN;
      },

      encodeParameters(state = this.state) {
        let search = '?'; //  + (state.screen != 'S' ? state.screen : ''); 保存しないことにした
        search += state.nspecies + "_" + state.nlattice;
        search += "_" + state.interact_seed + state.intset + "_" + state.world_seed;
        search += state.perterb  ? "" : "n";
        search += "_" + state.tail;
        search += "_" + state.scale;
        search += "_" + state.step;
        if(state.paletteSetting) {
          search += "_" + this.num2char(state.paletteSetting.iscale);
          search += ("0"+Math.round(state.paletteSetting.offset*255).toString(16)).slice(-2);
          search += ("0"+Math.round(state.paletteSetting.scale*16 - 16).toString(16)).slice(-2);
          search += Math.round(this.state.particleSize * 2);
        }
        return search;
      },

      setParameters(search) {
        let result = this.parseParameters(search);
        this.update(result);
      },

      parseParameters(search) {
        let result = Object.assign({}, this.default_state);
        if(!search) return result;  // 先頭に ? もついていない状態

        // 先頭の ? を外して _ で分ける
        let displaySetting;
        let options = search.substring(1).split('_');
        if(options.length == 4) {
          [result.nspecies, result.nlattice, result.interact_seed, 
           result.world_seed] = options;
        } else
        if(options.length == 5) {
          [result.nspecies, result.nlattice, result.interact_seed, 
           result.world_seed, result.tail] = options;
        } else
        if(options.length == 6) {
          [result.nspecies, result.nlattice, result.interact_seed, 
           result.world_seed, result.tail, result.scale] = options;
        } else
        if(options.length == 7) {
          [result.nspecies, result.nlattice, result.interact_seed, 
           result.world_seed, result.tail, result.scale, result.step] = options;
        } else
        if(options.length == 8) {
          [result.nspecies, result.nlattice, result.interact_seed, 
           result.world_seed, result.tail, result.scale, result.step, displaySetting] = options;
        } else {
          return {};
        }
        
        // 揺動
        let match = /^(.*)n$/.exec(result.world_seed);
        if(match) {
          result.world_seed = match[1];
          result.perterb = 0;
        }

        // スクリーンサイズ
        match = /^(XS|S|M|L|F)(.+)/.exec(result.nspecies);
        if(match) {
          result.screen = match[1];
          result.nspecies = match[2];
        }
        result.screen = "S";  // 無視する
        
        // 大文字のアルファベットは相互作用セットの指定
        if(/[A-Z]/.test(result.interact_seed.slice(-1))) {
          result.intset = result.interact_seed.slice(-1);
          result.interact_seed = result.interact_seed.slice(0,-1);
        }
        
        if(displaySetting) {
          this.state.paletteSetting ||= {}
          this.state.paletteSetting.iscale = this.char2num(displaySetting.slice(0, 1), 16);
          if(displaySetting.slice(1, 3)=='xx')  {
            displaySetting = displaySetting.slice(0, 1) +
                             ("0"+Math.round(Math.random()*255).toString(16)).slice(-2) +
                             displaySetting.slice(3);
          }
          this.state.paletteSetting.offset = parseInt(displaySetting.slice(1, 3), 16) / 255;
          if(displaySetting.slice(3, 5)=='xx')  {
            displaySetting = displaySetting.slice(0, 3) +
                             ("0"+Math.round(Math.random()*32).toString(16)).slice(-2) +
                             displaySetting.slice(5);
          }
          this.state.paletteSetting.scale  = 1 + parseInt(displaySetting.slice(3, 5), 16) / 16;
          result.particleSize  = displaySetting.slice(5) / 2;
        }

        return result;
      }

    }
  </script>
</plcontrols>
