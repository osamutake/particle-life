p<!-----------------------------------------------------------------

  ワールド生成パラメータを制御するためのコントロール
  css は bulma を使用

  props = {
  }

  this.state = {
    pause: false,
    recording: false,
    interact_seed: 2**53 * Math.random(),
    world_seed: 2**53 * Math.random(),
    nspecies: 6,
    nlattice: 30,
    scale: 1,
    tail: 0,
    maxfps: 20,
    intset: "",
  };

  EVENTS: どれも e.detail には state が入る
    update
    restart
    pause
    record

----------------------------------------------------------------->

<plcontrols>
  <div class="columns">
    <div class="column is-narrow field">
      <label for="recommendation" class="label">ワールド設定</label>
      <div class="select">
        <select id="recommendation" value="" onchange={ recommendationChange }>
          <option value="" >URLで</option>
          <option  each={ recommendation in recommendations } key={recommendation[1]} value={recommendation[1]}>{recommendation[0]}</option>
        </select>
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="interact_seed" class="label">描画制御</label>
      <div class="field has-addons">
        <p class="control">
          <button class="button" onclick={ ()=> this.dispatchEvent("restart", {randomize: false, fullScreen: false}) } id="replay" title="始めに戻ってリプレイ">
            <span class="icon is-small"><ion-icon name="play-skip-back"></ion-icon></span>
          </button>
        </p>
        <p class="control">
          <button id="pause" class={ state.pause ? "button is-danger" : "button" }
                  onclick={ ()=> { update({"pause": !state.pause }); dispatchEvent("pause", state); } } title="ポーズ／再開">
            <span class="icon is-small"><ion-icon name={ state.pause ? "play" : "pause" }></ion-icon></span>
          </button>
        </p>
        <p class="control">
          <button id="recording" class={ state.recording ? "button is-danger" : "button" } 
                  onclick={ ()=>{ update({"recording": !state.recording }); dispatchEvent("record", state); } } title="webm に録画">
            <span class="icon is-small"><ion-icon name={ state.recording ? "stop" : "ellipse" }></ion-icon></span>
          </button>
        </p>
        <p class="control">
          <button id="palette" class={ state.showPalette ? "button is-dark" : "button" } 
                  onclick={ ()=>{ update({"showPalette": !state.showPalette }) } } title="カラーパレット編集">
            <span class="icon is-small"><ion-icon name="color-palette"></ion-icon></span>
          </button>
        </p>
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="particleSize" class="label">粒径</label>
      <div class="control">
        <input class="input" id="particleSize" type="numeric"  value={state.particleSize} size="3" onchange={ editorChanged } min="0" step="0.5" max="127.5" /> 
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="screen" class="label">画面 &nbsp; <span class="icon is-clickable" onclick={ ()=> update({screen: "F"}) }><ion-icon name="expand"></ion-icon></span></label>
      <div class="select">
        <select id="screen" value={state.screen} onchange={ editorChanged }>
          <option value="XS">XS</option>
          <option value="S">S</option>
          <option value="M">M</option>
          <option value="L">L</option>
          <option value="F">Full</option>
        </select>
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="maxfps" class="label">最大fps</label>
      <div class="control">
        <input class="input" id="maxfps" type="numeric"  value={state.maxfps} size="3" onchange={ editorChanged } min="0" max="1000" step="10"/> 
      </div>
    </div>
    <div class="column is-narrow field">
      <label class="label">使い方</label>
      <div class="control">
        <button class="button is-info" onclick={props.onHelp}>
          <span class="icon is-small"><ion-icon name="help"></ion-icon></span>
        </button>
      </div>
    </div>
  </div>
  <div style={`display: ${ $('#recommendation').value=='?' ? 'block' : 'none' }`}>
  <div class="columns">
    <div class="column is-narrow field">
      <label for="nspecies" class="label">粒子種数</label>
      <div class="control">
        <input class="input" id="nspecies" type="numeric" value={state.nspecies} size="2" onchange={ editorChanged } min="1" max="200" step="1" />
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="nparticles" class="label">√粒子数</label>
      <div class="control">
        <input class="input" id="nlattice" type="numeric" value={state.nlattice} size="2" onchange={ editorChanged } min="5" max="300" step="10" />
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="scale" class="label">スケール</label>
      <div class="control">
        <input class="input" id="scale" type="numeric"  value={state.scale} size="2" onchange={ editorChanged } min="0.5" step="0.2" max="20" />
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="step" class="label">計算ステップ</label>
      <div class="control">
        <input class="input" id="step" type="numeric"  value={state.step} size="2" onchange={ editorChanged } min="0" max="2" step="0.1" /> 
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="tail" class="label">尾の長さ</label>
      <div class="control">
        <input class="input" id="tail" type="numeric"  value={state.tail} size="2" onchange={ editorChanged }  min="0" step={
          state.tail < 15 ? 1 :
          state.tail < 30 ? 2 : 10
        } /> 
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="perterb" class="label">揺動</label>
      <div class="control">
        <input id="perterb" type="checkbox" checked={state.perterb != 0} onchange={ editorChanged } /> 
      </div>
    </div>
  </div>
  <div class="columns">
    <div class="column is-narrow field">
      <label for="intset" class="label">相互作用セット</label>
      <div class="select">
        <select id="intset" value={state.intset} onchange={ editorChanged }>
          <option value="">デフォルト</option>
          <option value="A">多粒子種補正A</option>
          <option value="B">多粒子種補正B</option>
        </select>
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="interact_seed" class="label">相互作用シード</label>
      <div class="field has-addons">
        <div class="control">
          <input class="input" id="interact_seed" type="numeric" value={ state.interact_seed } onchange={ editorChanged } size="12" min="1">
        </div>
        <div class="control">
          <a class="button is-info" onclick={ regenerateInteractionSeed }>
            <span class="icon is-small"><ion-icon name="refresh"></ion-icon></span>
          </a>
        </div>
      </div>
    </div>
    <div class="column is-narrow field">
      <label for="world_seed" class="label">粒子配置シード</label>
      <div class="field has-addons">
        <div class="control">
          <input class="input" id="world_seed" type="numeric" value={ state.world_seed } onchange={ editorChanged } size="12" min="1">
        </div>
        <div class="control">
          <a class="button is-info" onclick={ regenerateWorldSeed }>
            <span class="icon is-small"><ion-icon name="refresh"></ion-icon></span>
          </a>
        </div>
      </div>
    </div>
  </div>

  <a class="button is-info is-small" id="show-editor" onclick={props.onShowEditor}>
    パラメータエディタを表示/非表示</a>
  </div>

  <div class="columns" style="display:none">
    <div class="column is-narrow field">
      <label for="webgl" class="label">WebGL</label>
      <div class="control">
        <input type="checkbox" id="webgl" checked="checked"/> 
      </div>
    </div>
  </div>


  <style type="scss">
    :host span.icon {
      margin: 0px -2px !important;
    }
    .columns {
      display: flex;
      max-width: var(--100vw);
      flex-wrap: wrap;
      @media screen and (min-width: 420px) and (max-width: 640px) {
        padding-left: 0.5em;
      }
    }
    .is-narrow {
      flex: none;
      width: unset;
    }
    .column.is-narrow.field {
      padding: 0.5rem;
    }
  </style>

  <script>
    export default {
      async onBeforeMount(props, state) {
        this.default_state = {
          pause: false,
          recording: false,
          interact_seed: 2**53 * Math.random(),
          world_seed: 2**53 * Math.random(),
          nspecies: 6,
          nlattice: 30,
          scale: 3,
          tail: 0,
          maxfps: 60,
          step: 1,
          intset: "",
          perterb: 0.001,
          screen: "S",
          particleSize: 4,
        };
        
        this.state = Object.assign({}, this.default_state);

        this.recommendations.push(...this.props.intf.recommendations);

        this.props.intf.getWorldOptions = (randomize, fullScreen) => {
          if(randomize)
            this.setParameters(this.getSearchString(randomize), fullScreen);
          return this.state;
        }

        this.props.intf.update = (...args) => 
          this.update(...args);

        this.props.intf.updatePaletteSetting = (setting) => {
          this.state.paletteSetting = setting;
          // update しない
        }

        this.props.intf.getWorldURL = () => {
          return location.href.replace(/[^\/]*$/, this.encodeParameters());
        }

        util.implementEventTarget(this);
        this.addEventListener("update", this.props.onUpdate);
        this.addEventListener("restart", this.props.onRestart);
        this.addEventListener("record", this.props.onRecord);
        this.addEventListener("pause", this.props.onPause);
      },

      onMounted() {
        this.setParameters(this.getSearchString(false));

        this.flashControl(this.$('#recommendation'), '#ff3');

        const canvas = document.getElementById("particles-display");
        canvas.addEventListener('fullscreenchange', (e) => {
          if(!document.fullscreenElement) {
            // フルスクリーンが終了した
            document.removeEventListener('keydown', this.keydownWhileFullScreen);
            this.state.screen = this.lastScreen;
            this.update();
          }
        });
      },

      flashing: false,

      async flashControl(control, color) {
        if(this.flashing) return;

        this.flashing = true;
        const original = control.style.backgroundColor;
        for(let i = 0; i < 5; i++) {
          control.style.backgroundColor = color;
          await util.sleep(400);
          control.style.backgroundColor = original;
          await util.sleep(400);
        }
        this.flashing = false;
      },

      recommendations: [['自分で', '?']],

      recommendationChange(e) {
        if(e.target.value == "?") {
          this.update();
        } else {
          this.dispatchEvent("restart", {randomize: true, fullScreen: false});
        }

        this.flashControl(document.getElementById('new-world'), '#880');
      },

      editorChanged(e) {
        let {id, value} = e.target;
        if(e.target.id == "perterb") {
          Object.assign(this.state, {perterb: (e.target.checked ? 0.001 : 0)});
        } else
        if(e.target.id == "scale") {
          Object.assign(this.state, {
            scale: value,
            step: Math.round(this.state.step * this.state.scale / value * 1000)/1000
          });
        } else {
          Object.assign(this.state, Object.fromEntries([[id, value]]));
        }
        const restartNeeded = ["nspecies", "nlattice", "scale", "intset", 
          "step", "world_seed", "interact_seed"].includes(e.target.id);
        if(restartNeeded) {
          this.dispatchEvent("restart", {randomize: false, fullScreen: false});
        }else{
          this.update();
        }
      },

      regenerateInteractionSeed() {
        this.update({ interact_seed: 2**53 * Math.random() });
        this.dispatchEvent("restart", {randomize: false, fullScreen: false});
      },
      regenerateWorldSeed() {
        this.update({ world_seed: 2**53 * Math.random() });
        this.dispatchEvent("restart", {randomize: false, fullScreen: false});
      },

      onBeforeUpdate(props, state) {
        // allows recalculation of context data before the update
        const rule = {
          pause: 'boolean',
          recording: 'boolean',
          interact_seed: ['required', 'integer', 'min:1'],
          world_seed: ['required', 'integer', 'min:1'],
          nspecies: ['required', 'integer', 'between:1,200'],
          nlattice: ['required', 'integer', 'between:5,300'],
          scale: ['required', 'numeric', 'between:0.5,20'],
          tail: ['required', 'numeric', 'min:0'],
          maxfps: ['required', 'numeric', 'between:0,1000'],
          intset: ['regex:/^[A-Z]?$/'],
          screen: ['required'],
          particleSize: ['required', 'numeric', 'between:0,127.5'],
        };

        state.validation = new Validator(state, rule);
        state.validation.passes();  // check!

        for(let id of Object.keys(rule)) {
          if(state.validation.errors.errors[id]) {
            this.$('#'+id).classList.add('is-danger');
            if(this.lastState && this.lastState[id])
              this.state[id] = this.lastState[id]; // 直前の値に戻す
          } else {
            this.$('#'+id).classList.remove('is-danger');
          }
        }
      },
      
      onUpdated(props, state) {
          this.dispatchEvent("update", this.state);

          if(state.screen == "F") 
            this.requestFullScreen();

          // 直前の設定を取っておく
          this.lastState = Object.assign({}, this.state);
      },
      
      requestFullScreen() {
        this.lastScreen = !this.lastState ? "S" :
                          this.lastState.screen == "F" ? (this.lastScreen || "S") 
                                          : this.lastState.screen;
        const canvas = document.getElementById("particles-display");
        canvas.requestFullscreen();
        if(!this.keydownWhileFullScreen) {
          this.keydownWhileFullScreen = (e) => {
            if(e.key == 'n' || e.key == 'N') {
              this.dispatchEvent("restart", {randomize: true, fullScreen: true});
            } else
            if(e.key == ' ') {
              this.$('#pause').click();
            }
          };
        }
        document.addEventListener('keydown', this.keydownWhileFullScreen);
      },

      num2char(n) {
        const offset = n < 10          ? 0x30           :     // '0'
                       n < 10 + 26     ? 0x41 - 10      :     // 'A'
                       n < 10 + 26 * 2 ? 0x61 - 10 - 26 : -1; // 'a'

        if(offset < 0) return "?";
        
        return String.fromCharCode(offset + n);
      },
      
      char2num(c) {
        if(c == '?') return NaN;
        c = c.charAt(0);
        let n = c.charCodeAt(0);
        return ('a' <= c && c <= 'z') ? n - 0x61 + 10 + 26 :
               ('A' <= c && c <= 'Z') ? n - 0x41 + 10      :
               ('0' <= c && c <= '9') ? n - 0x30           : NaN;
      },

      encodeParameters(state = this.state) {
        let search = '?'; //  + (state.screen != 'S' ? state.screen : ''); 保存しないことにした
        search += state.nspecies + "_" + state.nlattice;
        search += "_" + state.interact_seed + state.intset + "_" + state.world_seed;
        search += state.perterb  ? "" : "n";
        search += "_" + state.tail;
        search += "_" + state.scale;
        search += "_" + state.step;
        if(state.paletteSetting) {
          search += "_" + this.num2char(state.paletteSetting.iscale);
          search += ("0"+Math.round(state.paletteSetting.offset*255).toString(16)).slice(-2);
          search += ("0"+Math.round(state.paletteSetting.scale*16 - 16).toString(16)).slice(-2);
          search += Math.round(this.state.particleSize * 2);
        }
        return search;
      },

      setParameters(search, fullScreen = false) {
        let result = this.parseParameters(search);
        if(fullScreen) result.screen = "F";
        this.update(result);
      },

      getSearchString(randomizeSeeds = false) {
        // ワールド設定を読み取る
        let search = this.$('#recommendation').value;

        // 自分で設定なら現在値
        if(search == '?') search = this.encodeParameters();

        // URL 指定の場合
        if(!search) search = location.search;

        // URL で指定されてなければお勧め設定
        if(!search) {
          search = this.recommendations.find((rec)=> rec.length > 2)[1];
          this.$('#recommendation').value = search;
        }

        // シード値の処理
        let parts = search.split('_');
        if(!randomizeSeeds) {
          if(0 == parts[2].replace(/[^0-9]+$/, '')) {
            parts[2] = parts[2].replace(/[0-9]+/, this.state.interact_seed ||
                                                  2**56 * Math.random() );
          }
          if(0 == parts[3].replace(/[^0-9]+$/, '')) {
            parts[3] = parts[3].replace(/[0-9]+/, this.state.world_seed || 
                                                  2**56 * Math.random() );
          }
        } else {
          parts[2] = parts[2].replace(/[0-9]+/, 2**56 * Math.random());
          parts[3] = parts[3].replace(/[0-9]+/, 2**56 * Math.random());
        }
        search = parts.join('_');

        return search;
      },

      parseParameters(search) {
        if(!search)   // 何も指定されないときのデフォルト
          search = this.getSearchString(true);

        let result = Object.assign({}, this.default_state);

        // 先頭の ? を外して _ で分ける
        let displaySetting;
        let options = search.substring(1).split('_');
        if(options.length == 4) {
          [result.nspecies, result.nlattice, result.interact_seed, 
           result.world_seed] = options;
        } else
        if(options.length == 5) {
          [result.nspecies, result.nlattice, result.interact_seed, 
           result.world_seed, result.tail] = options;
        } else
        if(options.length == 6) {
          [result.nspecies, result.nlattice, result.interact_seed, 
           result.world_seed, result.tail, result.scale] = options;
        } else
        if(options.length == 7) {
          [result.nspecies, result.nlattice, result.interact_seed, 
           result.world_seed, result.tail, result.scale, result.step] = options;
        } else
        if(options.length == 8) {
          [result.nspecies, result.nlattice, result.interact_seed, 
           result.world_seed, result.tail, result.scale, result.step, displaySetting] = options;
        } else {
          return {};
        }
        
        // 揺動
        let match = /^(.*)n$/.exec(result.world_seed);
        if(match) {
          result.world_seed = match[1];
          result.perterb = 0;
        }

        // スクリーンサイズ
        match = /^(XS|S|M|L|F)(.+)/.exec(result.nspecies);
        if(match) {
          result.screen = match[1];
          result.nspecies = match[2];
        }
        result.screen = "S";  // 無視する
        
        // 大文字のアルファベットは相互作用セットの指定
        if(/[A-Z]/.test(result.interact_seed.slice(-1))) {
          result.intset = result.interact_seed.slice(-1);
          result.interact_seed = result.interact_seed.slice(0,-1);
        }
        
        if(displaySetting) {
          this.state.paletteSetting ||= {}
          this.state.paletteSetting.iscale = this.char2num(displaySetting.slice(0, 1), 16);
          if(displaySetting.slice(1, 3)=='xx')  { // offset
            displaySetting = displaySetting.slice(0, 1) +
                             ("0"+Math.round(Math.random()*255).toString(16)).slice(-2) +
                             displaySetting.slice(3);
          }
          this.state.paletteSetting.offset = parseInt(displaySetting.slice(1, 3), 16) / 255;
          if(displaySetting.slice(3, 5)=='xx')  { // scale
            let rand = Math.random() ** 4;  // ゼロに近い方をより多く
            if(rand < 0.2) rand = 0; // 全範囲を使う確率をある程度取る
            displaySetting = displaySetting.slice(0, 3) +
                             ("0"+Math.round(rand*32).toString(16)).slice(-2) +
                             displaySetting.slice(5);
          }
          this.state.paletteSetting.scale  = 1 + parseInt(displaySetting.slice(3, 5), 16) / 16;
          result.particleSize  = displaySetting.slice(5) / 2;
        }

        return result;
      }

    }
  </script>
</plcontrols>
