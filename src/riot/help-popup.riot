<help-popup>
  <div>
    <div class="background" onclick={ close }></div>
    <article class="message is-info" id="help-popup">
      <div class="message-header">
        <i18n>使い方</i18n>
        <button class="delete" onclick={ close }></button>
      </div>
      <div class="message-body">
        <p id="help-text"><raw html={ i18n.t(state.messages[state.i][0], state.messages[state.i][1]+"_help") }></raw></p>
        <div class="arrow arrow-lb"><i18n>ここ！</i18n></div>
        <div class="buttons">
          <button class="button" id="help-prev" onclick={()=> update({"i": state.i - 1})} if={ state.i !=0 }>
          <i18n>前へ</i18n></button>
          <button class="button is-info" id="help-next" onclick={()=> update({"i": state.i + 1})}><i18n>
          { state.i == state.n - 1 ? "閉じる" : "次へ" }</i18n></button>
        </div>
        <progress class="progress is-link" value={state.i+1} max={state.n} id="help-progress">{
          Math.round(state.i/state.n*100)} %</progress>
      </div>
    </div>
    </article>
    <slot messages={messages} />
  </div>

  <style type="scss">
    :host {
      .background {
        display: none;
      }
      #help-popup {
        display: none;
      }

      &.shown {
        .background {
          display: block;
        }
        
        #help-popup {
          display: block;
        }
      }
      .buttons {
        display: flex;
        justify-content: flex-end;
      }
        
      .progress {
        margin-top: 5px;
      }
      .background {
        position: fixed;
        background-color: #00000050;
        z-index: 10;
        top: 0px;
        left: 0px;
        width: 100vw;
        height: 100vh;
      }
      #help-popup {
        z-index: 15;
        position: absolute;
        left: 5vw;
        width: 550px;
        max-width: calc(var(--100vw) - 10vw);
        top: 160px;
      }
      #help-text {
        line-height: 1.5;
        min-height: 8em;
      }
      #next-button {
        margin: 5px 0px;
      }

      .arrow{
        position: absolute;
        display: block;
        text-decoration: none;
        font-size: 24px;
        box-sizing: border-box;
        
        color: white;
        padding: 5px;
        border-radius: 3px;
        background-color: #9c0;
        font-weight: bold;
        z-index: 10;
        margin-top: -10px;
      }
      .arrow::after {
        display: block;
        position: absolute;
        width: 20px;
        height: 20px;
        margin: 0 10px;
        border-bottom: 15px solid #9c0;
        border-right: 15px solid #9c0;
        transform: rotate(45deg);
        top: 35px;
        left: 10px;
        content: "";
      }
    }

  </style>

  <script>
    import helpContents from '../help-contents.js'

    export default {
      onBeforeMount(props, state) {
        this.i18n = i18n;
        this.onBeforeUpdate(props, state);
      },

      onMounted() {
        i18n.addEventListener('update', this.onI18nUpdate)
      },

      onUnmounted() {
        i18n.removeEventListener('update', this.onI18nUpdate)
      },

      onI18nUpdate() {
        this.update()
      },

      onBeforeUpdate(props, state) {
        props.intf.show = ()=> this.show();
        if(state.messages != helpContents) {
          state.messages = helpContents;
          state.n = helpContents.length;
          state.i = 0;
        }
        if(state.i >= state.n) this.close();
        if(state.i <  0      ) state.i = 0;

        this.messages = [];
        state.messages.forEach( (message) =>
          i18n.t(message[0], message[1]+"_help").split(/<br>[\s\n]*<br>/).forEach( (message) => {
            this.messages.push(message);
          })
        );
      },
      
      show() {
        if(this.root.classList.contains("shown"))
          return;

        const scrollTo = document.querySelector('app').getBoundingClientRect().top;
        window.scrollTo(0, scrollTo + window.scrollY);
        
        document.addEventListener('keydown', this.keydown);
        this.root.classList.add("shown");
        this.state.i = 0;
        this.update();
      },

      close() {
        document.removeEventListener('keydown', this.keydown);
        this.root.classList.remove("shown");
      },
      
      keydown(e) {
        if(e.key === 'Escape') {
          this.close();
        }
        if(e.key === 'Enter' || e.key === ' ' || e.key === 'ArrowRight') {
          e.preventDefault();
          this.state.i += 1;
          this.update();
        }
        if(e.key === 'ArrowLeft') {
          e.preventDefault();
          this.state.i -= 1;
          this.update();
        }
      },

      onUpdated(props, state) {
        const arrow = this.$('.arrow');
        const targetId = state.messages[state.i][1];
        if(!targetId) {
          arrow.style.display = "none";
          return;
        }
        
        // 表示しておかないと offsetTop を取得できない
        // https://stackoverflow.com/questions/42356461/offsettop-property-on-element-with-display-none-is-always-0
        let target = document.getElementById(targetId);
        if(target) {
          let targetRect = target.getBoundingClientRect();
          let targetTop = targetRect.top - 50;
          let targetLeft = targetRect.left + targetRect.width / 2 - 30;
          let arrowRect = arrow.getBoundingClientRect();
          arrow.style.display = "block";
          arrow.style.top  = (targetTop  + arrow.offsetTop  - arrowRect.top ) + "px";
          arrow.style.left = (targetLeft + arrow.offsetLeft - arrowRect.left) + "px";
          this.blinkElement(arrow);
        } else {
          this.cancelBlinkElement();
          arrow.style.display = "none";
        }
      },
      
      cancelBlinkElement: ()=> 0,

      async blinkElement(elem, display = "block") {
        this.cancelBlinkElement();

        let cancelRequested = false;
        this.cancelBlinkElement = ()=>{
          cancelRequested = true;
          elem.style.display = display;
        }

        for(let i = 0; i < 8; i++){
          elem.style.display = "none";
          await util.sleep(200);
          if(cancelRequested) break;
          
          elem.style.display = display;
          await util.sleep(600);
          if(cancelRequested) break;
        }
      }
    }
  </script>

</help-popup>
