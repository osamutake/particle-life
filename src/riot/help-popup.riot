<help-popup>
  <div class="background" onclick={close}></div>
  <article class="message is-info" id="help-popup">
    <div class="message-header">
      使い方
      <button class="delete" onclick={ close }></button>
    </div>
    <div class="message-body">
      <p id="help-text"><raw html={messages[state.i][0]}></raw>    <div class="arrow arrow-lb">ここ！</div></p>
      <div class="buttons">
        <button class="button" id="help-prev" onclick={()=> update({"i": state.i - 1})} if={ state.i !=0 }>
        前へ</button>
        <button class="button is-info" id="help-next" onclick={()=> update({"i": state.i + 1})}>
        { state.i == state.n - 1 ? "閉じる" : "次へ" }</button>
      </div>
      <progress class="progress is-link" value={state.i+1} max={state.n} id="help-progress">{Math.round(state.i/state.n*100)} %</progress>
    </div>
  </div>
  </article>

  <style type="scss">
    :host {
      display: none;
      .buttons {
        display: flex;
        justify-content: flex-end;
      }
        
      .progress {
        margin-top: 5px;
      }
      .background {
        position: fixed;
        background-color: #00000050;
        z-index: 10;
        top: 0px;
        left: 0px;
        width: 100vw;
        height: 100vh;
      }
      #help-popup {
        z-index: 15;
        position: absolute;
        left: 5vw;
        width: 550px;
        max-width: calc(var(--100vw) - 10vw);
        top: 40px;
      }
      #help-text {
        line-height: 1.5;
        min-height: 8em;
      }
      #next-button {
        margin: 5px 0px;
      }

      .arrow{
        position: absolute;
        display: block;
        text-decoration: none;
        font-size: 24px;
        box-sizing: border-box;
        
        color: white;
        padding: 5px;
        border-radius: 3px;
        background-color: #9c0;
        font-weight: bold;
        z-index: 10;
      }
      .arrow::after {
        display: block;
        position: absolute;
        width: 20px;
        height: 20px;
        margin: 0 10px;
        border-bottom: 15px solid #9c0;
        border-right: 15px solid #9c0;
        transform: rotate(45deg);
        top: 25px;
        left: 10px;
        content: "";
      }
    }

  </style>

  <script>
    export default {
      onBeforeMount() {
        this.messages = [
          [`粒子に命が宿る世界をのんびり眺めながら渡り歩くサイトです<br>
            <br>
            飽きたら [次のワールドを生成] を押すと異なる世界に移れます`,
           "new-world"
          ],
          [`[ワールド設定] でお勧めの設定を選んだら何度か押してみてください`,
           "recommendation"
          ],
          [`[画面] で Full を選ぶ、
            あるいは <span class="icon"><ion-icon name="expand"></ion-icon></span> 
            を押すとフルスクリーン表示にできます<br><br>
            フルスクリーン表示中はスペースキーでポーズ／再開、 N キーで次のワールドへ移れます`,
           "screen"
          ],
          [`メイン画面のダブルクリック/タップでワールドに指を突っ込めます`,
           "particles-display"
          ],
          [`[このワールドをシェア&nbsp;
             <span class="icon"><ion-icon name="share-social"></ion-icon></span></a>] 
             で今いるワールドへのリンクをクリップボードへコピーできます`,
           "copy-url"
          ],
          [`[描画制御] の 
            <span class="icon is-small"><ion-icon name="color-palette"></ion-icon></span> 
            で現れるカラースケールを上下左右にいじると配色を変えられます`,
           "palette"
          ],
          [`[描画制御] の 
            <span class="icon is-small"><ion-icon name="play-skip-back"></ion-icon></span> 
            で現在のワールドをはじめからリプレイできます<br>
            <br>
            それではどうぞのんびりお楽しみください`,
           "replay"
          ],
        ],

        this.state = {
          n: this.messages.length,
          i: 0
        };
        
        this.root.show = ()=> this.show();
      },

      onMounted() {
        this.update();
      },
      
      onBeforeUpdate(props, state) {
        if(this.state.i >= this.state.n) 
          this.close();
        if(this.state.i < 0)
          this.state.i = 0;
      },
      
      show() {
        const scrollTo = document.querySelector('h1 + p').getBoundingClientRect().top;
        window.scrollTo(0, scrollTo + window.scrollY);
        
        if(!this.keydown) {
          this.keydown = (e) => {
            if(e.key === 'Escape') {
              this.close();
            }
            if(e.key === 'Enter' || e.key === ' ' || e.key === 'ArrowRight') {
              e.preventDefault();
              this.state.i += 1;
              this.update();
            }
            if(e.key === 'ArrowLeft') {
              e.preventDefault();
              this.state.i -= 1;
              this.update();
            }
          };
          document.addEventListener('keydown', this.keydown);
        }
        
        this.root.style.display = "block";
        this.state.i = 0;
        this.update();
      },

      close() {
        document.removeEventListener('keydown', this.keydown);
        this.keydown = null;

        this.root.style.display = "none";
        this.state.i = 0;
      },
      
      onUpdated(props, state) {
        const arrow = this.$('.arrow');
        const targetId = this.messages[this.state.i][1];
        if(!targetId) {
          arrow.style.display = "none";
          return;
        }
        
        // 表示しておかないと offsetTop を取得できない
        // https://stackoverflow.com/questions/42356461/offsettop-property-on-element-with-display-none-is-always-0
        arrow.style.display = "block";
        
        let target = document.getElementById(targetId);
        let targetRect = target.getBoundingClientRect();
        let targetTop = targetRect.top - 50;
        let targetLeft = targetRect.left + targetRect.width / 2 - 30;
        let arrowRect = arrow.getBoundingClientRect();
        arrow.style.top  = (targetTop  + arrow.offsetTop  - arrowRect.top ) + "px";
        arrow.style.left = (targetLeft + arrow.offsetLeft - arrowRect.left) + "px";
        
        this.blinkElement(arrow);
      },
      
      async blinkElement(elem, display = "block") {
        if(this.blinking) return;

        this.blinking = true;
        for(let i = 0; i < 8; i++){
          elem.style.display = "none";
          await util.sleep(200);
          elem.style.display = display;
          await util.sleep(600);
        }
        this.blinking = false;
      }
    }
  </script>

</help-popup>
