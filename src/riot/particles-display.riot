<!-----------------------------------------------------------------

  粒子を表示するコントロール
  css は bulma を使用

  props = {
    width
    height
    intf
  }

  intf = {
    world: 
    colorFunc: 
    repelX: NaN,
    repelY: NaN,
    update: null,
    render: null
  }

  state = {
    offsetX: 0,   // 内部でのみ使われる
    offsetY: 0,   // 内部でのみ使われる
    tail: 0       // 内部でのみ使われる
  }

----------------------------------------------------------------->

<particles-display>
  <canvas id="particles-display" width={props.width} height={props.height}></canvas>

  <style type="scss">
    :host {
      line-height: 1;

      > div {
        margin: 0px;
      }
    }
    canvas {
      touch-action: none;
      margin: 0px;
      max-width: var(--100vw);
      max-height: var(--100vw);
    }
    @media screen and (max-width: 640px) {
      canvas {
        margin-left: -0.75rem;
        margin-right: -0.75rem;
      }
    }
    @media screen and (min-width: 1000px) {
      canvas {
        min-width: 600px;
        min-height: 600px;
      }
    }
  </style>

  <script>
    export default {
      onBeforeMount(props, state) {
        Object.assign(state, {
          offsetX: 0,
          offsetY: 0,
          tail: 0,
          particleSize: 3,
          scale: 1
        })

        props.intf.update = (...args) =>
          this.update(...args);

        props.intf.render = (...args) =>
          this.render(...args);

        props.intf.canvas = () => this.$('canvas');
      },

      onMounted() {
        this.registerPointerHandlers()
      },

      get effectiveScale() {
        let scale = this.state.scale;
        if(0.8 < scale && scale < 1) scale = 1;
        return scale;
      },

      registerPointerHandlers() {
        const canvas = this.$("#particles-display");

        // マウス座標から x, y 座標 [-0.5, 0.5) に直す
        const mouse2xySub = (mouseX, mouseY) => {
          const size = Math.min(canvas.clientWidth, canvas.clientHeight)
          const ox = (canvas.clientWidth -  size) / 2
          const oy = (canvas.clientHeight - size) / 2
          const scale = this.effectiveScale;
          const x = ((mouseX - ox) / size - 0.5) / scale + 0.5
          const y = ((mouseY - oy) / size - 0.5) / scale + 0.5
          return [x, y]
        };

        // [-0.5, 0.5) に巻き取る
        const mouse2xy = (mouseX, mouseY) => {
          let [x, y] = mouse2xySub(mouseX, mouseY)
          x += this.state.offsetX
          y += this.state.offsetY
          return [x - Math.round(x), y - Math.round(y)]
        };

        // 中央領域にあるかどうか
        const mouseInDisplay = (mouseX, mouseY) => {
          const [x, y] = mouse2xySub(mouseX, mouseY)
          return 0 < x && x < 1 && 0 < y && y < 1
        };
        
        let canvasTapCount = 0;
        let mouseDoubleDown = false;
        let pinchL, pinchScale;
        this.defineDragBehavior( canvas, {
          down: (e, x, y, points) => {
            if(e.buttons != 1) return;  // 左ボタン以外が押されていれば無視
            const keys = Object.keys(points).filter(k=> points[k].buttons == 1);
            if(keys.length != 1) {
              if(keys.length == 2) {
                // ピンチ開始
                const [e0, e1] = keys.map(k=> points[k]);
                pinchL = Math.hypot(e1.offsetX - e0.offsetX,  // 距離
                                    e1.offsetY - e0.offsetY);
                pinchScale = this.state.scale; // 初期スケール
                e.preventDefault();
                return;
              } else {
                return; // マルチタッチは無視
              }
            }

            e.preventDefault();
            if( canvasTapCount == 0 ) { // シングルタップ
              canvasTapCount++;
              setTimeout( () =>{ canvasTapCount = 0; }, 350 ) ;
            } else {                    // ダブルタップ
              canvasTapCount = 0 ;
              if(!mouseInDisplay(x,y)){
                this.dispatchEvent("restart");
                return;
              }
              mouseDoubleDown = true;
              [this.props.intf.repelX, this.props.intf.repelY] = mouse2xy(x, y)
            }
          },
          move: (e, mouseDown, newX, newY, oldX, oldY, points) => {
            if(mouseDown) {               // 左ボタン以外が押されていれば無視
              if(e.buttons != 1) return;  // 左ボタンが押されてなくても無視
              const keys = Object.keys(points).filter(k=> points[k].buttons == 1);
              if(keys.length != 1) {
                if(keys.length == 2) {
                  // ピンチ
                  const [e0, e1] = keys.map(k=> points[k]);
                  const l = Math.hypot(e1.offsetX - e0.offsetX,  // 距離
                                       e1.offsetY - e0.offsetY);
                  this.state.scale = pinchScale * l / pinchL;
                  this.state.scale = Math.min(4, Math.max(0.5, this.state.scale));
                  e.preventDefault();
                  this.render();
                  return;
                } else {
                  return; // マルチタッチは無視
                }
              }

              e.preventDefault();
              if(!mouseDoubleDown) {    
                const size = Math.min(canvas.clientWidth, canvas.clientHeight);
                const [dx, dy] = [newX - oldX, newY - oldY];
                if(e.ctrlKey) {
                  this.state.scale *= 1 - 2 * dy / size;
                  this.state.scale = Math.min(4, Math.max(0.5, this.state.scale));
                } else {
                  // スクロールする
                  this.state.offsetX -= dx / size / this.state.scale;
                  this.state.offsetX -= Math.round(this.state.offsetX);
                  this.state.offsetY -= dy / size / this.state.scale; 
                  this.state.offsetY -= Math.round(this.state.offsetY);
                }
                this.render();
              } else {                  // 斥力
                [this.props.intf.repelX, this.props.intf.repelY] = mouse2xy(newX, newY)
              }
            }
          },
          up: (e, x, y, points) => {
            mouseDoubleDown = false;
            [this.props.intf.repelX, this.props.intf.repelY] = [NaN, NaN]
          }
        });
      },

      onUpdated(props, state) {
        const screens = {
          XS: 400, S: 600, M: 900, L: 1200, XL: 1500, 
          F: Math.min(window.screen.width, window.screen.height)
        }
        this.state.size = screens[this.state.screen] ?? 600
        let [w, h] = [this.state.size, this.state.size]
        if(this.state.screen == "F")
          [w, h] = [window.screen.width, window.screen.height]
        
        // 表示サイズはこちらで指定
        let canvas = this.$('canvas');
        [canvas.style.width, canvas.style.height] = [w + "px", h + "px"];

        // 描画解像度は実デバイスに合わせる
        const r = window.devicePixelRatio;
        this.state.size *= r;
        [canvas.width, canvas.height] = [w * r, h * r]

        this.render()
      },

      // 粒子サイズは画面サイズ相対
      calcParticleSize() {
        return this.state.particleSize / 600 * this.state.size;
      },

      // WebGL が使えない場合の通常の描画
      render2dCore(g, world, colorFunc) {
        let canvas = this.$("canvas");
        g.setTransform(1,0,0,1,0,0);
        g.scale(this.state.size, this.state.size);
        g.translate(0.5, 0.5);

        // パレットを作成
        const n = world.nspecies;
        const palette = [...Array(n)].map((_, i) => colorFunc(i/n));

        // 粒子半径
        let particleSize = this.calcParticleSize();
        const r = particleSize / this.state.size / 2;

        // 境界から r 以内の粒子は反対側にも描く必要がある
        world.particles.forEach( (sp, x, y) => {
          const draw2 = (_x, _y) => {
            g.beginPath();
            g.fillStyle = palette[sp];
            g.arc(_x, _y, r, 0, 2 * Math.PI);
            g.fill();
          };
          
          const draw = (_x, _y) => {
            draw2(_x, _y);
            if(_y < -0.5 + r) draw2(_x, _y + 1);
            if(_y > +0.5 - r) draw2(_x, _y - 1);
          }

          x += 0.5; x -= Math.round(x);
          y += 0.5; y -= Math.round(y);
          
          draw(x, y);
          if(x < -0.5 + r) draw(x + 1, y);
          if(x > +0.5 - r) draw(x - 1, y);
        });
      },

      /// source を g のスクロール位置に描画する
      drawImageWithOffset(g, source) {
        const s = this.state.size;
        const [dx, dy] = [-this.state.offsetX * s, -this.state.offsetY * s]

        const region = (sx, sy) => {  // ４象限を計算する
          const x1 = (s - dx) % s; const y1 = (s - dy) % s; 
          const x2 = (dx + s) % s; const y2 = (dy + s) % s; 
          return [
            Math.min(x1, sx ? 0 : s),  Math.min(y1, sy ? 0 : s),
            Math.abs(x1-(sx ? 0 : s)), Math.abs(y1-(sy ? 0 : s)), 
            Math.min(x2, sx ? s : 0),  Math.min(y2, sy ? s : 0),
            Math.abs(x1-(sx ? 0 : s)), Math.abs(y1-(sy ? 0 : s)) ];
        }
        g.drawImage(source, ...region(0, 0));
        g.drawImage(source, ...region(1, 0));
        g.drawImage(source, ...region(0, 1));
        g.drawImage(source, ...region(1, 1));
      },

      // WebGL 粒子表示クラス
      ParticleRendererGL: class {
        constructor(gl) {
          this.gl = gl;
          this.program = this.createProgram(gl);
          
          // vertices buffer を準備 (データはまだ入れない)
          this.vbuffer = new util.glBuffer(gl, gl.ARRAY_BUFFER);
        }

        destructor() {
          if(this.texture) {
            util.finalizer.unregister(this.texture)
            this.gl.deleteTexture(this.texture);
          }
          util.destruct(this.program, this.vbuffer);
        }
        
        /// program 作成
        createProgram(gl) {
          // viewport からはみ出た粒子の端が viewport 内に入る
          // 影響を入れるため、範囲外の粒子座標を扱う必要がある
          // SHORT だと [-1, 1] より外の座標を指定できないので、
          // あらかじめ 1/2 した座標を渡して vertex shader で
          // ２倍して復元する

          // vertex shader source code
          const vsrc = `
            attribute vec4 a_position;
            attribute vec4 a_color;
            uniform float u_point_size;
            varying vec4 v_color;
            void main(void) {
              gl_Position = a_position;
              gl_Position.x *= 2.0; // あらかじめ半分にして渡していた
              gl_Position.y *= 2.0;
              gl_PointSize = u_point_size;
              v_color = a_color;
            }
          `;

          // fragment shader source code
          const fsrc = `
            precision mediump float;
            uniform sampler2D u_texture;
            uniform int       u_use_texture;
            varying vec4      v_color;
            void main(void) {
              vec4 c = vec4(1.0);
              if(bool(u_use_texture)) {
                c = texture2D(u_texture, gl_PointCoord);
              }
              if(c.a == 0.0) {
                discard;
              } else {
                gl_FragColor = v_color * c;
              }
            }
          `;

          const program = new util.glProgram(
            gl, vsrc, fsrc, 
            ["a_position", "a_color"], 
            ["u_point_size", "u_texture", "u_use_texture"]
          );
          program.use();

          return program;
        }
        
        /// src から テクスチャを読み込む
        loadTexture(src) {
          const gl = this.gl;
          const img = new Image();
          img.onload = (e) => {
            let texture;
            if(this.texture) {
              // 中途半端で使われないよう一旦 null にする
              texture = this.texture;
              this.texture = null;
            } else {
              texture = gl.createTexture();
              util.finalizer.register(this, [gl.deleteTexture, [texture]], texture)
            }
            gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
              gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
            // 読み込み終了
            this.texture = texture;
          }
          // ソースをセット
          img.src = src;
        }
        
        /// render
        // nTexture < 0 ならテクスチャを使わずに描画
        render(nTexture, w, h, world, colorFunc, particleSize, frameBuffer = null) {
          if(frameBuffer) { // 与えられていればバッファーへ描画する
            frameBuffer.bind(()=>
              this.#renderCore(nTexture, w, h, world, colorFunc, particleSize)
            );
          } else {
            this.#renderCore(nTexture, w, h, world, colorFunc, particleSize)
          }
        }

        #renderCore(nTexture, w, h, world, colorFunc, particleSize) {
          const {gl, program, vbuffer, texture} = this;
          program.use();

          if(texture && nTexture >= 0) {
            program.u_texture.i = nTexture; // n 番を指定
            gl.activeTexture(gl[`TEXTURE${nTexture}`]); // gl.TEXTUREn
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            program.u_use_texture.i = true;
          } else {
            program.u_use_texture.i = false;
          }

          gl.viewport(0, 0, w, h);
          gl.disable(gl.DEPTH_TEST);

          // https://stackoverflow.com/questions/39341564/webgl-how-to-correctly-blend-alpha-channel-png
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.ONE_MINUS_DST_COLOR, gl.ONE ); // screen
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);

          // 一旦消去
          gl.clearColor(0, 0, 0, 0);  // 背景色は透明 (!= 黒)
          gl.clear(gl.COLOR_BUFFER_BIT);

          program.u_point_size.f = Number.parseFloat(particleSize) + 0.25;

          // "#000000" 形式の配色を数値に直す
          let palette = [...Array(world.nspecies)].map((_, i) => {
              const c = colorFunc(i/world.nspecies);
              return [ parseInt(c.slice(1, 3), 16),   // r
                        parseInt(c.slice(3, 5), 16),   // g
                        parseInt(c.slice(5, 7), 16) ]  // b
            }
          );

          const [vertices, nvertices] = 
            world.particles.vertices(palette, particleSize/w);
          if((vbuffer.dataLength || 0) < vertices.length) {
            vbuffer.data(vertices, gl.DYNAMIC_DRAW);
          } else {
            vbuffer.subData(0, vertices);
          }
          let size = 2; // sizeof(SHORT);  
          //                               items                 stride    offset
          program.a_position.ptr = [vbuffer, 2, gl.SHORT, true, size * 5, 0       ];
          program.a_color.ptr    = [vbuffer, 3, gl.SHORT, true, size * 5, size * 2];
          vbuffer.bind(()=>{
            gl.drawArrays(gl.POINTS, 0, nvertices);
          });
        }
      },

      recreateCanvas(canvas) {
        const clone = canvas.cloneNode();
        canvas.replaceWith(clone);
        canvas.width = 0;   // こうしておくと早くメモリが解放される？？？
        canvas.height = 0;  // https://tech.mobilefactory.jp/entry/2019/12/17/143000
        this.registerPointerHandlers();
        return clone;
      },

      /// 描画する
      render() {
        const world = this.props.intf.world();
        const colorFunc = this.props.intf.colorFunc();
        if(!world || !colorFunc) return;
        if(world.recreating) return;

        let canvas = this.$("canvas");
        const canvasMode = document.getElementById('canvas-mode');
        if(canvasMode.value == "webgl") {
          let gl = canvas.getContext('webgl');
          if(!gl) {
            // 2d 描画した後は一回作り直さないといけない
            canvas = this.recreateCanvas(canvas);
            gl = canvas.getContext('webgl');
          }
          if(gl) {
            if(this.buffer2) {
              this.buffer2.width = 0;
              delete this.buffer2;
              this.buffer3.width = 0;
              delete this.buffer3;
            }
            this.renderGL(gl, canvas, world, colorFunc);
            return;
          }
          // WebGL が使えない
          canvasMode.value = "screen";
          document.querySelector('#canvas-mode option[value="webgl"]').disabled = true;
        } 

        // 古いものがあれば消しておく
        util.destruct(
          this.rendererGL,
          this.frameBuffer1,
          this.frameBuffer2A,
          this.frameBuffer2B,
          this.frameRendererTail,
          this.frameRendererOffset,
        );
        delete this.rendererGL;
        delete this.frameBuffer1;
        delete this.frameBuffer2A;
        delete this.frameBuffer2B;
        delete this.frameRendererTail;
        delete this.frameRendererOffset;

        // 2d context を得る
        let g = canvas.getContext('2d');
        // WebGL で描画した後は一回作り直さないといけない
        if(!g) {
          canvas = this.recreateCanvas(canvas);
          g = canvas.getContext('2d');
        }
        if(!g) {
          throw new Error('canvas 2d context is not available');
        }
        this.render2d(g, canvas, world, colorFunc);
      },

      render2d(g, canvas, world, colorFunc) {
        const s = this.state.size;
        const w = canvas.width;
        const h = canvas.height;

        // this.buffer2 に offset を無視した画像を作る
        if(!this.buffer2) {
          this.buffer2 = canvas.cloneNode();
          this.buffer3 = canvas.cloneNode();
        } else
        if(this.buffer2.width  != w || this.buffer2.height != h) {
            this.buffer2.width = w; this.buffer2.height = h;
            this.buffer3.width = w; this.buffer3.height = h;
        }

        // まずは普通に描画
        const g3 = this.buffer3.getContext('2d');
        g3.globalCompositeOperation = "source-over";
        g3.setTransform(1, 0, 0, 1, 0, 0);
        g3.fillStyle = "#000000";
        g3.fillRect(0, 0, w, h);

        // screen モードでの描画は Firefox で話にならないほど
        // 遅くなるのだけれど、そもそも WebGL が使えない環境の
        // Firefox をサポートする意味があるのかどうかが疑わしいので
        // 気にせずデフォルト動作を screen にしておく

        const canvasMode = document.getElementById('canvas-mode');
        if(canvasMode.value == "screen") {
          g3.globalCompositeOperation = "screen";
        } else {
          g3.globalCompositeOperation = "source-over";
        }
        this.render2dCore(g3, world, colorFunc);

        // 尾を引かせる背景処理
        const g2 = this.buffer2.getContext('2d');
        this.render2dBackground(g2, w, h)

        // lighten モードの描画は Firefox ではかなり時間がかかる
        // のだけれど １枚だけならまあ何とか？
        g2.globalCompositeOperation = "lighten";
        g2.drawImage(this.buffer3, 0, 0);

        // Offet と scale を反映して描画しなおす
        g.setTransform(1, 0, 0, 1, 0, 0);
        g.translate( w/2, h/2 );
        g.scale(this.effectiveScale, this.effectiveScale);
        g.translate( - s/2, - s/2 );  // 中央を原点にしてスケール
        this.drawImageWithOffset(g, this.buffer2);

        let ss = s * this.effectiveScale;
        g.fillStyle = "#00000080"
        for(let i = -Math.ceil((w-ss)/ss/2); i <= Math.ceil((w-ss)/ss/2); i++) {
          for(let j = -Math.ceil((h-ss)/ss/2); j <= Math.ceil((h-ss)/ss/2); j++) {
            if(i==0 && j==0) continue;
            g.setTransform(1, 0, 0, 1, 0, 0);
            g.translate( w/2, h/2 );
            g.scale(this.effectiveScale, this.effectiveScale);
            g.translate( - s/2 + i * s, - s/2 + j * s );  // 中央を原点にしてスケール
            this.drawImageWithOffset(g, this.buffer2);
            
            g.setTransform(1, 0, 0, 1, 0, 0);
            g.fillRect((w-ss)/2 + i * ss, (h-ss)/2 + j * ss, ss, ss);
            
          }
        }
      },

      // 尾を引かせる背景処理
      render2dBackground(g, w, h) {
        let t = this.state.tail;
        if(t > 50) {
          this.tailCount = (this.tailCount ?? 0) + 50 / t;
          t = 50;
        } else {
          this.tailCount = 1;
        }

        if(this.tailCount >= 1) {
          // 背景塗りつぶし
          let style = '#000000';  // 真っ黒
          if( t > 0 ) {  
            // 尾を引かせるときは alpha を指定する
            style += ('0' + ((255 / (1.0 + 1.0 * t)) | 0).toString(16)).substr(-2);
          }
          g.setTransform(1, 0, 0, 1, 0, 0);

          g.fillStyle = style;
          g.globalCompositeOperation = "source-over"
          g.fillRect(0, 0, w, h);

          // 微妙に消えないのを消すための隠し味
          g.fillStyle = "#010101";
          g.globalCompositeOperation = "difference"
          g.fillRect(0, 0, w, h);

          this.tailCount -= 1;
        }
      },

      renderGL(gl, canvas, world, colorFunc) {

        if(!this.rendererGL) {
          this.rendererGL = new this.ParticleRendererGL(gl);

          // 32px x 32px circle
          this.rendererGL.loadTexture(`data:image/png;base64,
            iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABJklEQVRYw82X
            oW4CQRRFz5sGV9O0+PYLUFiyGsVH9GtQWJJqPqFqFbYGvgB8SxBULSUXwSOp
            IM22XebtsZPZeyc77819Rk0k3QNDYAD0gCfgzpe3wApYAnPg1cw2NIGkvqSp
            pJ3qs/M9/f8IdyWNJVX6O5V/o/tb8UJSqeYoJRV1xUeSFmqehaRRnZNfQ/y7
            ieKnf17q+pQX74RfllyML5ValdFAdS7R5B6egQ756Lgm5h1uDdySl0/gMXl7
            zS2Oaw6T9/YoBskflih6JukdeAgy8GGSvoCbIAOHRDDJw0QU2+RJJopV8hgV
            xTJ5hotiHt+KPb3OAk4/M7PNuQxfgH1G8b1rnp5jM3sDJhkNTFyzRZEsPJS2
            Ipa3YjBpxWiWczi16PH8CAvfPn83UHV5AAAAAElFTkSuQmCC`);
        }

        let tail = this.state.tail;
        if(!this.frameBuffer1) {
          this.frameBuffer1  = new util.glFrameBuffer(gl, this.state.size, this.state.size, false);
          this.frameBuffer2A = new util.glFrameBuffer(gl, this.state.size, this.state.size, false);
          this.frameBuffer2B = new util.glFrameBuffer(gl, this.state.size, this.state.size, false);
          
          const fsrcTail = `
            precision mediump float;
            uniform sampler2D u_texture;
            uniform sampler2D u_texture2;
            uniform float u_tail;
            uniform int u_time;
            uniform vec2 u_size;
            void main(void){
              vec2 uv = gl_FragCoord.xy / u_size;
              vec4 now = texture2D(u_texture, uv);
              vec4 last = texture2D(u_texture2, uv);
              vec4 c;
              float u_tail1 = u_tail + 1.0;
              float comp = u_tail1 / 255.0;
              // 割合で減らなくなったら 間隔をあけて減らす
              c.r = last.r * u_tail / u_tail1; 
              if((last.r - c.r) * 255.0 < 1.0)
                if((u_time - u_time/(int(comp/last.r))*(int(comp/last.r))) == 0) c.r -= 1.0/256.0;
              c.g = last.g * u_tail / u_tail1;
              if((last.g - c.g) * 255.0 < 1.0) 
                if((u_time - u_time/(int(comp/last.g))*(int(comp/last.g))) == 0) c.g -= 1.0/256.0;
              c.b = last.b * u_tail / u_tail1;
              if((last.b - c.b) * 255.0 < 1.0) 
                if((u_time - u_time/(int(comp/last.b))*(int(comp/last.b))) == 0) c.b -= 1.0/256.0;
              c.a = 1.0;
              gl_FragColor = max(c, now);
            }
          `;
          this.frameRendererTail = new util.glTextureRenderer(gl, fsrcTail, 
            ["u_size", "u_tail", "u_time", "u_texture2"]);
          
          const fsrcOffset = `
            precision mediump float;
            uniform sampler2D u_texture;
            uniform vec2 u_size;
            uniform float u_scale;
            uniform vec2 u_offset;
            void main(void){
              // ここで uv から gl_FragColor を求める
              float size = min(u_size.x, u_size.y);       // 正方形の一辺
              vec2 of = (u_size - size) / 2.0;            // 左上の座標
              vec2 uv = (gl_FragCoord.xy - of) / size;    // 正規化
              uv = (uv - 0.5) / u_scale + 0.5 + u_offset; // 中央からスケール＋オフセット
              uv.x -= floor(uv.x);                        // 周期境界
              uv.y -= floor(uv.y);                        // 周期境界
              gl_FragColor = texture2D(u_texture, uv);

              // 範囲チェック
              vec2 test = ((gl_FragCoord.xy - of) / size - 0.5) / u_scale + 0.5;
              if( test.x < 0.0 || test.y < 0.0 || test.x > 1.0 || test.y > 1.0 ) 
                gl_FragColor.rgb /= 2.0;  // 範囲外なら暗くする
            }
          `;
          this.frameRendererOffset = new util.glTextureRenderer(gl, fsrcOffset, 
            ["u_size", "u_scale", "u_offset"]);
          
          tail = 0;
          this.counter = 1;
        }

        // 1倍に吸い付くようにする
        let scale = this.effectiveScale;

        // 拡大できるよう常に2倍で描画する
        // ２倍以上の拡大表示では少しぼやけるが気にしない
        let ssize = 2 * this.state.size;
        let psize = 2 * this.calcParticleSize(); 

        if(this.frameBuffer1.width != ssize) {
          this.frameBuffer1.resize( ssize, ssize)
          this.frameBuffer2A.resize(ssize, ssize)
          this.frameBuffer2B.resize(ssize, ssize)
          tail = 0;
          this.counter = 1;
        }

        // frameBuffer1 へ描画
        this.rendererGL.render(
          0, ssize, ssize,
          world, colorFunc, psize,
          this.frameBuffer1
        );

        // frameBuffer2A/B に交互に描画する
        let src  = this.counter % 2 == 0 ? this.frameBuffer2A : this.frameBuffer2B;
        let dest = this.counter % 2 == 0 ? this.frameBuffer2B : this.frameBuffer2A;

        // 前回の描画結果 src に frameBuffer1 の結果を書き加えたものを dest へ描画
        this.frameRendererTail.render(1, this.frameBuffer1.texture, (gl, program)=> {
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          gl.viewport(0,0, ssize, ssize);
          program.u_tail.f = tail;
          program.u_size.f = [ssize, ssize];
          program.u_time.i = this.count;
          program.u_texture2.i = 2;
          gl.activeTexture(gl.TEXTURE2);
          gl.bindTexture(gl.TEXTURE_2D, src.texture);
        }, dest);

        // dest に Offset 処理をして canvas へ描画
        this.frameRendererOffset.render(3, dest.texture, (gl, program)=> {
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          gl.viewport(0,0,canvas.width,canvas.height);
          program.u_size.f = [canvas.width, canvas.height];
          program.u_offset.f = [this.state.offsetX, -this.state.offsetY];
          program.u_scale.f = scale;
        });

        this.counter += 1;
      }
    }
  </script>
</particles-display>
