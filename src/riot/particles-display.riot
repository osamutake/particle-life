<!-----------------------------------------------------------------

  粒子を表示するコントロール
  css は bulma を使用

  props = {
    width
    height
  }
  state = {
    repelX: 0,  // 外から参照されることを想定
    repelY: 0,  // 外から参照されることを想定
    offsetX: 0,   // 内部でのみ使われる
    offsetY: 0,   // 内部でのみ使われる
    tail: 0       // 内部でのみ使われる
  }

----------------------------------------------------------------->

<particles-display>
  <canvas width={props.width} height={props.height}></canvas>

  <style type="scss">
    :host {
      > div {
        margin: 0px;
      }
      canvas {
        touch-action: none;
        margin: 0px;
      }
    }
  </style>

  <script>
    export default {

      onMounted() {

        this.state = {
          repelX: NaN,
          repelY: NaN,
          offsetX: 0,
          offsetY: 0,
          tail: 0
        }

        let canvas = this.$('canvas');

        // スクロール処理に使うワーキングキャンバスを作成
//        this.workingCanvas = canvas.cloneNode();

//        let g = canvas.getContext('2d');
//        g.scale(canvas.width, canvas.height);
//        g.translate(0.5, 0.5);
        
        // マウス座標から x, y 座標に直す
        const mouse2xy = (mouseX, mouseY) => {
          return [
            mouseX / canvas.width  - 0.5 + this.state.offsetX, 
            mouseY / canvas.height - 0.5 + this.state.offsetY
          ];
        };
          
        let canvasTapCount = 0;
        let mouseDoubleDown = false;
        this.defineDragBehavior( canvas, {
          down: (e, x, y) => {
          	if( canvasTapCount == 0 ) {
            	// シングルタップ
          		canvasTapCount++;
          		setTimeout( () =>{ canvasTapCount = 0; }, 350 ) ;

          	} else {
            	// ダブルタップ
          		canvasTapCount = 0 ;

              mouseDoubleDown = true;
              [this.state.repelX, this.state.repelY] = mouse2xy(x, y)
          	}
          },
          move: (e, mouseDown, newX, newY, oldX, oldY) => {
            if(mouseDown) {
              if(!mouseDoubleDown) {
                // スクロールする
                const [dx, dy] = [newX - oldX, newY - oldY];
                this.scroll(dx, dy);
                this.state.offsetX -= dx / canvas.width; 
                this.state.offsetX -= Math.round(this.state.offsetX);
                this.state.offsetY -= dy / canvas.height; 
                this.state.offsetY -= Math.round(this.state.offsetY);
              } else {
                [this.state.repelX, this.state.repelY] = mouse2xy(newX, newY)
              }
            }
          },
          up: (e, x, y) => {
            mouseDoubleDown = false;
            [this.state.repelX, this.state.repelY] = [NaN, NaN]
          }
        });

      },

      // 画面をスクロールする
      // TODO: そもそも裏で普通に書いておいて offset でずらしたところに
      //       貼り付ける方が良い気がしてきた
      scroll(dx, dy) {
        let canvas = this.$('canvas');
        let wcanvas = this.workingCanvas;
        wcanvas.getContext('2d').drawImage(canvas, 0, 0); // そのままコピーする

        const g = canvas.getContext('2d');
        g.setTransform(1,0,0,1,0,0);
        g.globalAlpha = 1;
        
        const [w, h] = [canvas.width, canvas.height];
        const region = (sx, sy) => {  // ４象限を計算する
          const x1 = (w - dx) % w; const y1 = (h - dy) % h; 
          const x2 = (dx + w) % w; const y2 = (dy + h) % h; 
          return [
            Math.min(x1, sx ? 0 : w),  Math.min(y1, sy ? 0 : h),
            Math.abs(x1-(sx ? 0 : w)), Math.abs(y1-(sy ? 0 : h)), 
            Math.min(x2, sx ? w : 0),  Math.min(y2, sy ? h : 0),
            Math.abs(x1-(sx ? 0 : w)), Math.abs(y1-(sy ? 0 : h)) ];
        }

        g.drawImage(wcanvas, ...region(0, 0));
        g.drawImage(wcanvas, ...region(1, 0));
        g.drawImage(wcanvas, ...region(0, 1));
        g.drawImage(wcanvas, ...region(1, 1));

        g.scale(canvas.width, canvas.height);
        g.translate(0.5, 0.5);
      },

      // 描画する
      render(world, colorFunc) {
        if(!world || !colorFunc) return;

        let canvas = this.$('canvas');

/*
        g = canvas.getContext('2d');

        // 背景塗りつぶし
        let style = '#000000';  // 真っ黒
        if( this.state.tail > 0 ) {  
          // 尾を引かせるときは alpha を指定する
          style += ('0' + ((255 / (1.0 + 1.0 * this.state.tail)) | 0).toString(16)).substr(-2);
        }
        g.fillStyle = style;
        g.fillRect(-0.5, -0.5, 1, 1);
        
        // パレットを作成
        const n = world.nspecies;
        const palette = [...Array(n)].map((_, i) => colorFunc(i/n));

        // 粒子の描画
        const r = world.particle_radius;
        const ox = this.state.offsetX;
        const oy = this.state.offsetY;
        world.particles.forEach( (sp, x, y) => {
          g.beginPath();
          g.fillStyle = palette[sp];
          x -= ox; x -= Math.round(x);
          y -= oy; y -= Math.round(y);
          g.arc(x, y, r, 0, 2 * Math.PI);
          g.fill();
        });
*/

        gl = canvas.getContext('webgl'); 

        if(!this.vertices || this.vertices.length != world.nparticles * 5) {

          /*=========================Shaders========================*/

          // vertex shader source code
          var vshaderSrc = `
            attribute vec4 a_position;
            attribute vec4 a_color;
            varying vec4 v_color;
            void main(void) {
              gl_Position = a_position;
              gl_PointSize = 2.5;
              v_color = a_color;
            }
          `;

          // Create a vertex shader object
          var vshader = gl.createShader(gl.VERTEX_SHADER);
          gl.shaderSource(vshader, vshaderSrc);
          gl.compileShader(vshader);

          var fshaderSrc = `
            precision mediump float;
            varying vec4 v_color;
            void main(void) {
              gl_FragColor = v_color;
            }
          `;

          var fshader = gl.createShader(gl.FRAGMENT_SHADER);
          gl.shaderSource(fshader, fshaderSrc);
          gl.compileShader(fshader);
           
          var shaderProgram = gl.createProgram();
          gl.attachShader(shaderProgram, vshader); 
          gl.attachShader(shaderProgram, fshader);
          gl.linkProgram(shaderProgram);
          gl.useProgram(shaderProgram);
          gl.program = shaderProgram;

          // 一旦消去
          gl.clearColor(0, 0, 0, 1);
          gl.disable(gl.DEPTH_TEST);
          gl.clear(gl.COLOR_BUFFER_BIT);

          let vertex_buffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

          /*======== Associating shaders to buffer objects ========*/

          let size = 2; // vertices.BYTES_PER_ELEMENT

          let a_position = gl.getAttribLocation(gl.program, 'a_position');
          gl.vertexAttribPointer(a_position, 2, gl.SHORT, true, size * 5, 0);
          gl.enableVertexAttribArray(a_position);

          let a_color = gl.getAttribLocation(gl.program, 'a_color');
          gl.vertexAttribPointer(a_color, 3, gl.SHORT, true, size * 5, size * 2);
          gl.enableVertexAttribArray(a_color);

          /*============= Drawing the primitive ===============*/

          gl.disable(gl.DEPTH_TEST);
          gl.clear(gl.COLOR_BUFFER_BIT);

          // Set the view port
          gl.viewport(0, 0, canvas.width, canvas.height);

          this.vertices = new Int16Array(5 * world.nparticles);
        }
          // 一旦消去
          gl.disable(gl.DEPTH_TEST);
          gl.clear(gl.COLOR_BUFFER_BIT);
          gl.clearColor(0, 0, 0, 1);

        let palette = [...Array(world.nspecies)].map((_, i) => {
            const c = colorFunc(i/world.nspecies);
            return [parseInt(c.slice(1, 3), 16), parseInt(c.slice(3, 5), 16), parseInt(c.slice(5, 7), 16)]
          }
        );

        for(let i = 0; i < world.nparticles; i++) {
          this.vertices[5 * i    ] = world.particles.mem[6 * i + 2] >>> 16;
          this.vertices[5 * i + 1] = world.particles.mem[6 * i + 3] >>> 16;

          let c = palette[world.particles.mem[6 * i + 0]];
          this.vertices[5 * i + 2] = c[0] * 127;
          this.vertices[5 * i + 3] = c[1] * 127;
          this.vertices[5 * i + 4] = c[2] * 127;
        }

        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);

        gl.drawArrays(gl.POINTS, 0, world.nparticles);

      }
    }
  </script>
</particles-display>
