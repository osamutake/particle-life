<!-----------------------------------------------------------------

  粒子を表示するコントロール
  css は bulma を使用

  props = {
    width
    height
  }

  state = {
    repelX: 0,  // 外から参照されることを想定
    repelY: 0,  // 外から参照されることを想定
    offsetX: 0,   // 内部でのみ使われる
    offsetY: 0,   // 内部でのみ使われる
    tail: 0       // 内部でのみ使われる
  }

----------------------------------------------------------------->

<particles-display>
  <canvas id="particles-display" width={props.width} height={props.height}></canvas>

  <style type="scss">
    :host {
      line-height: 1;

      > div {
        margin: 0px;
      }
      canvas {
        touch-action: none;
        margin: 0px;
        max-width: var(--100vw);
      }
      @media screen and (max-width: 640px) {
        canvas {
          margin-left: -0.75rem;
          margin-right: -0.75rem;
        }
      }
      @media screen and (min-width: 1000px) {
        canvas {
          min-width: 600px;
        }
      }
    }
  </style>

  <script>
    export default {

      onMounted() {

        this.state = {
          repelX: NaN,
          repelY: NaN,
          offsetX: 0,
          offsetY: 0,
          tail: 0,
          particleSize: 2.5
        }

        this.initializeRequired = true;

        let canvas = this.$('canvas');

        // ワーキングキャンバスを作成
        this.buffer = canvas.cloneNode();   // WebGL で使う
        this.buffer.width = this.buffer.width * 2;
        this.buffer.height = this.buffer.height * 2;
        this.buffer2 = canvas.cloneNode();  // スクロール処理の前

        // デバッグ用に表示する場合
        // this.root.insertBefore(this.buffer, canvas.nextSibling);
        // this.root.insertBefore(this.buffer2, this.buffer.nextSibling);

        // マウス座標から x, y 座標に直す
        const mouse2xy = (mouseX, mouseY) => {
          let x = mouseX / canvas.clientWidth  + this.state.offsetX;
          let y = mouseY / canvas.clientHeight + this.state.offsetY;
          return [x - Math.round(x), y - Math.round(y)];
        };
          
        let canvasTapCount = 0;
        let mouseDoubleDown = false;
        this.defineDragBehavior( canvas, {
          down: (e, x, y) => {
            if( canvasTapCount == 0 ) {
              // シングルタップ
              canvasTapCount++;
              setTimeout( () =>{ canvasTapCount = 0; }, 350 ) ;

            } else {
              // ダブルタップ
              canvasTapCount = 0 ;

              mouseDoubleDown = true;
              [this.state.repelX, this.state.repelY] = mouse2xy(x, y)
            }
          },
          move: (e, mouseDown, newX, newY, oldX, oldY) => {
            if(mouseDown) {
              if(!mouseDoubleDown) {
                // スクロールする
                const [dx, dy] = [newX - oldX, newY - oldY];
                this.state.offsetX -= dx / canvas.width; 
                this.state.offsetX -= Math.round(this.state.offsetX);
                this.state.offsetY -= dy / canvas.height; 
                this.state.offsetY -= Math.round(this.state.offsetY);
                this.render();
              } else {
                [this.state.repelX, this.state.repelY] = mouse2xy(newX, newY)
              }
            }
          },
          up: (e, x, y) => {
            mouseDoubleDown = false;
            [this.state.repelX, this.state.repelY] = [NaN, NaN]
          }
        });

      },

      onUpdated(props, state) {
        const screens = {
          XS: 400, S: 600, M: 900, L: 1200, XL: 1500
        }

        let size = screens[this.state.screen]
        let canvas = this.$('canvas');
        if(canvas && (canvas.width != size)) {
          [canvas.width, canvas.height] =
          [this.buffer2.width, this.buffer2.height] = [size, size];
          [this.buffer.width, this.buffer.height] = [size*2, size*2];
          this.initializeRequired = true;
        }

        this.render();
      },


      // WebGL が使えない場合の通常の描画

      render_2d(g, world, colorFunc) {
        let canvas = this.$("canvas");
        g.scale(canvas.width, canvas.height);
        g.translate(0.5, 0.5);

        // パレットを作成
        const n = world.nspecies;
        const palette = [...Array(n)].map((_, i) => colorFunc(i/n));

        // 粒子の描画
        let size = this.calcParticleSize();
        const r = size / canvas.width / 2;

        g.globalCompositeOperation = "screen"

        world.particles.forEach( (sp, x, y) => {
          const draw2 = (_x, _y) => {
            g.beginPath();
            g.fillStyle = palette[sp];
            g.arc(_x, _y, r, 0, 2 * Math.PI);
            g.fill();
          };
          
          const draw = (_x, _y) => {
            draw2(_x, _y);
            if(_y < -0.5 + r) draw2(_x, _y + 1);
            if(_y > +0.5 - r) draw2(_x, _y - 1);
          }

          x += 0.5; x -= Math.round(x);
          y += 0.5; y -= Math.round(y);
          
          draw(x, y);
          if(x < -0.5 + r) draw(x + 1, y);
          if(x > +0.5 - r) draw(x - 1, y);
        });
      },

      // 粒子サイズは画面サイズ相対にしておく
      calcParticleSize() {
        return this.state.particleSize / 600 * this.$('canvas').width;
      },

      // WebGL の初期化

      initialize_gl(gl) {
        /*=========================Shaders========================*/

        // vertex shader source code
        var vshaderSrc = `
          attribute vec4 a_position;
          attribute vec4 a_color;
          uniform float u_point_size;
          varying vec4 v_color;
          void main(void) {
            gl_Position = a_position;
            gl_PointSize = u_point_size;
            v_color = a_color;
          }
        `;

        // Create a vertex shader object
        var vshader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vshader, vshaderSrc);
        gl.compileShader(vshader);

        var fshaderSrc = `
          precision mediump float;
          uniform sampler2D u_texture;
          uniform int       u_use_texture;
          varying vec4      v_color;
          void main(void) {
            vec4 c = vec4(1.0);
            if(bool(u_use_texture)) {
              c = texture2D(u_texture, gl_PointCoord);
            }
            if(c.a == 0.0) {
              discard;
            } else {
              gl_FragColor = v_color * c;
            }
          }
        `;

        var fshader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fshader, fshaderSrc);
        gl.compileShader(fshader);
         
        var shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vshader); 
        gl.attachShader(shaderProgram, fshader);
        gl.linkProgram(shaderProgram);
        gl.useProgram(shaderProgram);
        gl.program = shaderProgram;

        let vertex_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

        /*======== Associating shaders to buffer objects ========*/

        let size = 2; // vertices.BYTES_PER_ELEMENT

        let a_position = gl.getAttribLocation(gl.program, 'a_position');
        gl.vertexAttribPointer(a_position, 2, gl.SHORT, true, size * 5, 0);
        gl.enableVertexAttribArray(a_position);

        let a_color = gl.getAttribLocation(gl.program, 'a_color');
        gl.vertexAttribPointer(a_color, 3, gl.SHORT, true, size * 5, size * 2);
        gl.enableVertexAttribArray(a_color);

        // Set the view port
        gl.viewport(0, 0, this.buffer.width, this.buffer.height);

        let u_texture = gl.getUniformLocation(gl.program, 'u_texture');
        gl.uniform1i(u_texture, 0);

        // 一旦使わない設定にしておく
        let u_use_texture = gl.getUniformLocation(gl.program, 'u_use_texture');
        gl.uniform1i(u_use_texture, false);

        var img = new Image();
        img.onload = function(e){
          let texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
          gl.generateMipmap(gl.TEXTURE_2D);
          gl.bindTexture(gl.TEXTURE_2D, null);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);

          // 使えるようになったので ON にする
          gl.uniform1i(u_use_texture, true);
        };
        
        // 32px x 32px circle
        img.src = `data:image/png;base64,
            iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABJklEQVRYw82X
            oW4CQRRFz5sGV9O0+PYLUFiyGsVH9GtQWJJqPqFqFbYGvgB8SxBULSUXwSOp
            IM22XebtsZPZeyc77819Rk0k3QNDYAD0gCfgzpe3wApYAnPg1cw2NIGkvqSp
            pJ3qs/M9/f8IdyWNJVX6O5V/o/tb8UJSqeYoJRV1xUeSFmqehaRRnZNfQ/y7
            ieKnf17q+pQX74RfllyML5ValdFAdS7R5B6egQ756Lgm5h1uDdySl0/gMXl7
            zS2Oaw6T9/YoBskflih6JukdeAgy8GGSvoCbIAOHRDDJw0QU2+RJJopV8hgV
            xTJ5hotiHt+KPb3OAk4/M7PNuQxfgH1G8b1rnp5jM3sDJhkNTFyzRZEsPJS2
            Ipa3YjBpxWiWczi16PH8CAvfPn83UHV5AAAAAElFTkSuQmCC`;

        gl.disable(gl.DEPTH_TEST);

        // https://stackoverflow.com/questions/39341564/webgl-how-to-correctly-blend-alpha-channel-png
        gl.enable(gl.BLEND);
//        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.blendFunc( gl.ONE_MINUS_DST_COLOR, gl.ONE ); // screen


        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);

        gl.bufferDataRequired = true;
      },

      // WebGL による描画

      render_gl(gl, world, colorFunc) {

        // 一旦消去
        gl.clearColor(0, 0, 0, 0);  // 背景色は透明
        gl.clear(gl.COLOR_BUFFER_BIT);

        let psize = this.calcParticleSize();
        let u_point_size = gl.getUniformLocation(gl.program, 'u_point_size');
        gl.uniform1f(u_point_size, Number.parseFloat(psize)+0.25);

        let palette = [...Array(world.nspecies)].map((_, i) => {
            const c = colorFunc(i/world.nspecies);
            return [parseInt(c.slice(1, 3), 16), parseInt(c.slice(3, 5), 16), parseInt(c.slice(5, 7), 16)]
          }
        );

        const [vertices, nvertices] = world.particles.vertices(palette, psize/this.buffer.width);
        if(gl.bufferDataRequired) {
          gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);
        } else {
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);
        }
        gl.drawArrays(gl.POINTS, 0, nvertices);
      },


      // source を g のスクロール位置に描画する

      drawImageWithOffset(g, source) {
        const [w, h] = [source.width, source.height];
        const [dx, dy] = [-this.state.offsetX * w, -this.state.offsetY * h]

        const region = (sx, sy) => {  // ４象限を計算する
          const x1 = (w - dx) % w; const y1 = (h - dy) % h; 
          const x2 = (dx + w) % w; const y2 = (dy + h) % h; 
          return [
            Math.min(x1, sx ? 0 : w),  Math.min(y1, sy ? 0 : h),
            Math.abs(x1-(sx ? 0 : w)), Math.abs(y1-(sy ? 0 : h)), 
            Math.min(x2, sx ? w : 0),  Math.min(y2, sy ? h : 0),
            Math.abs(x1-(sx ? 0 : w)), Math.abs(y1-(sy ? 0 : h)) ];
        }
        g.drawImage(source, ...region(0, 0));
        g.drawImage(source, ...region(1, 0));
        g.drawImage(source, ...region(0, 1));
        g.drawImage(source, ...region(1, 1));
      },

      // 描画する
      render() {

        world = this.world && this.world();
        colorFunc = this.colorFunc && this.colorFunc();
        if(!world || !colorFunc) return;


        // this.buffer2 に offset を無視した画像を作る

        // まず尾を引かせる背景処理

        const g2 = this.buffer2.getContext('2d');
        g2.setTransform(1, 0, 0, 1, 0, 0);

        let t = this.state.tail;
        if(t > 50) {
          this.tailCount = (this.tailCount || 0) + 50/t;
          t = 50;
        } else {
          this.tailCount = 1;
        }

        if(this.tailCount >= 1) {
          // 背景塗りつぶし
          let style = '#000000';  // 真っ黒
          if( t > 0 ) {  
            // 尾を引かせるときは alpha を指定する
            style += ('0' + ((255 / (1.0 + 1.0 * t)) | 0).toString(16)).substr(-2);
          }
          g2.fillStyle = style;
          g2.globalCompositeOperation = "source-over"
          g2.fillRect(0, 0, this.buffer2.width, this.buffer2.height);

          g2.fillStyle = "#010101";
          g2.globalCompositeOperation = "difference"
          g2.fillRect(0, 0, this.buffer2.width, this.buffer2.height);

          this.tailCount -= 1;
        }

        // WebGL は使えるか？
        let gl = this.buffer.getContext('webgl'); 

        // https://stackoverflow.com/questions/39341564/webgl-how-to-correctly-blend-alpha-channel-png
        const checkWebgl = document.getElementById('webgl');
        if(!gl || !checkWebgl.checked) {
          if(!gl) { // WebGL が使えない
            checkWebgl.checked = "";
            checkWebgl.disabled = "disabled";
          }

          // WebGL を使わない描画
          g2.globalCompositeOperation = "source-over"
          this.render_2d(g2, world, colorFunc);
          g2.setTransform(1, 0, 0, 1, 0, 0);
        } else {
          if(this.initializeRequired) {
            this.initialize_gl(gl);
            this.initializeRequired = false;
          }

          this.render_gl(gl, world, colorFunc);

          g2.globalCompositeOperation = "source-over";
          let size = this.buffer2.width;
          g2.drawImage(this.buffer, 
              size/2, size/2, size, size, // source
              0, 0, size, size);          // dest
        }

        const canvas = this.$("canvas");
        const g = canvas.getContext('2d');
        this.drawImageWithOffset(g, this.buffer2);
      }
    }
  </script>
</particles-display>
