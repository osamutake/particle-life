<!-----------------------------------------------------------------

  粒子を表示するコントロール
  css は bulma を使用

  props = {
    width
    height
    intf
  }

  intf = {
    world: 
    colorFunc: 
    repelX: NaN,
    repelY: NaN,
    update: null,
    render: null
  }

  state = {
    offsetX: 0,   // 内部でのみ使われる
    offsetY: 0,   // 内部でのみ使われる
    tail: 0       // 内部でのみ使われる
  }

----------------------------------------------------------------->

<particles-display>
  <canvas id="particles-display" width={props.width} height={props.height}></canvas>

  <style type="scss">
    :host {
      line-height: 1;

      > div {
        margin: 0px;
      }
      canvas {
        touch-action: none;
        margin: 0px;
        max-width: var(--100vw);
      }
      @media screen and (max-width: 640px) {
        canvas {
          margin-left: -0.75rem;
          margin-right: -0.75rem;
        }
      }
      @media screen and (min-width: 1000px) {
        canvas {
          min-width: 600px;
        }
      }
    }
  </style>

  <script>
    export default {
      onBeforeMount(props, state) {
        this.state = {
          offsetX: 0,
          offsetY: 0,
          tail: 0,
          particleSize: 3
        }

        props.intf.update = (...args) =>
          this.update(...args);

        props.intf.render = (...args) =>
          this.render(...args);

        props.intf.canvas = () => this.$('canvas');
      },

      onMounted() {
        util.implementEventTarget(this);

        // マウス座標から x, y 座標 [-0.5, 0.5) に直す
        const mouse2xy = (mouseX, mouseY) => {
          const size = Math.min(canvas.clientWidth, canvas.clientHeight);
          const ox = (canvas.clientWidth - size) / 2;
          const oy = (canvas.clientHeight - size) / 2;
          const x = (mouseX - ox) / size + this.state.offsetX;
          const y = (mouseY - oy) / size + this.state.offsetY;
          return [x - Math.round(x), y - Math.round(y)];
        };
          
        const mouse2xyIn = (mouseX, mouseY) => {
          const size = Math.min(canvas.clientWidth, canvas.clientHeight);
          const ox = (canvas.clientWidth - size) / 2;
          const oy = (canvas.clientHeight - size) / 2;
          const x = (mouseX - ox) / size;
          const y = (mouseY - oy) / size;
          return 0 < x && x < 1 && 0 < y && y < 1;
        };
          
        const canvas = this.$("#particles-display");
        let canvasTapCount = 0;
        let mouseDoubleDown = false;
        this.defineDragBehavior( canvas, {
          down: (e, x, y) => {
            e.preventDefault();
            if( canvasTapCount == 0 ) { // シングルタップ
              canvasTapCount++;
              setTimeout( () =>{ canvasTapCount = 0; }, 350 ) ;
            } else {                    // ダブルタップ
              canvasTapCount = 0 ;
              if(!mouse2xyIn(x,y)){
                this.props.onRestart();
                return;
              }
              mouseDoubleDown = true;
              [this.props.intf.repelX, this.props.intf.repelY] = mouse2xy(x, y)
            }
          },
          move: (e, mouseDown, newX, newY, oldX, oldY) => {
            if(mouseDown) {
              e.preventDefault();
              if(!mouseDoubleDown) {    // スクロールする
                const [dx, dy] = [newX - oldX, newY - oldY];
                const size = Math.min(canvas.clientWidth, canvas.clientHeight);
                this.state.offsetX -= dx / size; 
                this.state.offsetX -= Math.round(this.state.offsetX);
                this.state.offsetY -= dy / size; 
                this.state.offsetY -= Math.round(this.state.offsetY);
                this.render();
              } else {                  // 斥力
                [this.props.intf.repelX, this.props.intf.repelY] = mouse2xy(newX, newY)
              }
            }
          },
          up: (e, x, y) => {
            mouseDoubleDown = false;
            [this.props.intf.repelX, this.props.intf.repelY] = [NaN, NaN]
          }
        });

        this.update();
      },

      onUpdated(props, state) {
        const screens = {
          XS: 400, S: 600, M: 900, L: 1200, XL: 1500, F: 0
        }
        
        let canvas = this.$('canvas');
        this.state.size = screens[this.state.screen] || 600;
        if(this.state.screen == "F") {
          this.state.size = Math.min(window.screen.width, window.screen.height);
          [canvas.width, canvas.height] = [window.screen.width, window.screen.height]
          const checkWebgl = document.getElementById('webgl');
          if(!checkWebgl.checked) // webgl が使えないときは正方形のままで
            [canvas.width, canvas.height] = [this.state.size, this.state.size]
          if(this.state.size < 500){
            this.state.size *= 2;
            canvas.width *= 2;
            canvas.height *= 2;
          }
        } else {
          [canvas.width, canvas.height] = [this.state.size, this.state.size]
        }
        this.render();
      },

      // WebGL が使えない場合の通常の描画
      render_2d(g, world, colorFunc) {
        let canvas = this.$("canvas");
        g.scale(canvas.width, canvas.height);
        g.translate(0.5, 0.5);

        // パレットを作成
        const n = world.nspecies;
        const palette = [...Array(n)].map((_, i) => colorFunc(i/n));

        // 粒子の描画
        let size = this.calcParticleSize();
        const r = size / canvas.width / 2;

        g.globalCompositeOperation = "screen"

        world.particles.forEach( (sp, x, y) => {
          const draw2 = (_x, _y) => {
            g.beginPath();
            g.fillStyle = palette[sp];
            g.arc(_x, _y, r, 0, 2 * Math.PI);
            g.fill();
          };
          
          const draw = (_x, _y) => {
            draw2(_x, _y);
            if(_y < -0.5 + r) draw2(_x, _y + 1);
            if(_y > +0.5 - r) draw2(_x, _y - 1);
          }

          x += 0.5; x -= Math.round(x);
          y += 0.5; y -= Math.round(y);
          
          draw(x, y);
          if(x < -0.5 + r) draw(x + 1, y);
          if(x > +0.5 - r) draw(x - 1, y);
        });
      },

      /// source を g のスクロール位置に描画する
      drawImageWithOffset(g, source) {
        const [w, h] = [source.width, source.height];
        const [dx, dy] = [-this.state.offsetX * w, -this.state.offsetY * h]

        const region = (sx, sy) => {  // ４象限を計算する
          const x1 = (w - dx) % w; const y1 = (h - dy) % h; 
          const x2 = (dx + w) % w; const y2 = (dy + h) % h; 
          return [
            Math.min(x1, sx ? 0 : w),  Math.min(y1, sy ? 0 : h),
            Math.abs(x1-(sx ? 0 : w)), Math.abs(y1-(sy ? 0 : h)), 
            Math.min(x2, sx ? w : 0),  Math.min(y2, sy ? h : 0),
            Math.abs(x1-(sx ? 0 : w)), Math.abs(y1-(sy ? 0 : h)) ];
        }
        g.drawImage(source, ...region(0, 0));
        g.drawImage(source, ...region(1, 0));
        g.drawImage(source, ...region(0, 1));
        g.drawImage(source, ...region(1, 1));
      },

      // 粒子サイズは画面サイズ相対にしておく
      calcParticleSize() {
        const canvas = this.$('canvas');
        const size = Math.min(canvas.width, canvas.height);
        return this.state.particleSize / 600 * size;
      },

      // 粒子表示クラス
      ParticleRendereGL: class {
        constructor(gl) {
          this.gl = gl;
          this.program = this.createProgram(gl);
        }
        
        /// program 作成
        createProgram(gl) {
          // viewport からはみ出た粒子の端が viewport 内に入る
          // 影響を入れるため、範囲外の粒子座標を扱う必要がある
          // SHORT だと [-1, 1] より外の座標を指定できないので、
          // あらかじめ 1/2 した座標を渡して vertex shader で
          // ２倍して復元する

          // vertex shader source code
          const vsrc = `
            attribute vec4 a_position;
            attribute vec4 a_color;
            uniform float u_point_size;
            varying vec4 v_color;
            void main(void) {
              gl_Position = a_position;
              gl_Position.x *= 2.0; // あらかじめ半分にして渡していた
              gl_Position.y *= 2.0;
              gl_PointSize = u_point_size;
              v_color = a_color;
            }
          `;

          // fragment shader source code
          const fsrc = `
            precision mediump float;
            uniform sampler2D u_texture;
            uniform int       u_use_texture;
            varying vec4      v_color;
            void main(void) {
              vec4 c = vec4(1.0);
              if(bool(u_use_texture)) {
                c = texture2D(u_texture, gl_PointCoord);
              }
              if(c.a == 0.0) {
                discard;
              } else {
                gl_FragColor = v_color * c;
              }
            }
          `;

          const program = new util.glProgram(
            gl, vsrc, fsrc, 
            ["a_position", "a_color"], 
            ["u_point_size", "u_texture", "u_use_texture"]
          );
          program.use();

          // verticle buffer を準備 (データはまだ入れない)
          program.vbuffer = new util.glBuffer(gl, gl.ARRAY_BUFFER);

          return program;
        }
        
        /// src から テクスチャを読み込む
        loadTexture(src) {
          const gl = this.gl;
          const img = new Image();
          img.onload = (e) => {
            let texture;
            if(this.texture) {
              // 中途半端で使われないよう一旦 null にする
              texture = this.texture;
              this.texture = null;
            } else {
              texture = gl.createTexture();
            }
            gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
              gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
            // 読み込み終了
            this.texture = texture;
          }
          // ソースをセット
          img.src = src;
        }
        
        /// render
        // n_texture < 0 ならテクスチャを使わずに描画
        render(n_texture, w, h, world, colorFunc, particleSize, frameBuffer = null) {
          if(frameBuffer) frameBuffer.bind(); // 与えられていればバッファーへ描画する
          try {
            const {gl, program, texture} = this;
            program.use();

            if(texture && n_texture >= 0) {
              program.u_texture.i(n_texture); // n 番を指定
              gl.activeTexture(gl[`TEXTURE${n_texture}`]); // gl.TEXTUREn
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
              program.u_use_texture.i(true);
            } else {
              program.u_use_texture.i(false);
            }

            gl.viewport(0, 0, w, h);
            gl.disable(gl.DEPTH_TEST);

            // https://stackoverflow.com/questions/39341564/webgl-how-to-correctly-blend-alpha-channel-png
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.ONE_MINUS_DST_COLOR, gl.ONE ); // screen
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);

            // 一旦消去
            gl.clearColor(0, 0, 0, 0);  // 背景色は透明
            gl.clear(gl.COLOR_BUFFER_BIT);

            this.program.u_point_size.f(Number.parseFloat(particleSize) + 0.25);

            let palette = [...Array(world.nspecies)].map((_, i) => {
                const c = colorFunc(i/world.nspecies);
                return [ parseInt(c.slice(1, 3), 16), 
                         parseInt(c.slice(3, 5), 16), 
                         parseInt(c.slice(5, 7), 16) ]
              }
            );

            const [vertices, nvertices] = 
              world.particles.vertices(palette, particleSize/w);
            if((program.vbuffer.dataLoaded || 0) < vertices.length) {
              program.vbuffer.data(vertices, gl.DYNAMIC_DRAW);
            } else {
              program.vbuffer.subData(0, vertices);
            }
            let size = 2; // sizeof(SHORT);  
            //                                 items                 stride    offset
            program.a_position.ptr(this.program.vbuffer, 2, gl.SHORT, true, size * 5, 0       );
            program.a_color.ptr(   this.program.vbuffer, 3, gl.SHORT, true, size * 5, size * 2);
            program.vbuffer.bind(()=>{
              gl.drawArrays(gl.POINTS, 0, nvertices);
            });
          } finally {
            if(frameBuffer) frameBuffer.unbind();
          }
        }
      },

      /// 描画する
      render() {

        const world = this.props.intf.world();
        const colorFunc = this.props.intf.colorFunc();
        if(!world || !colorFunc) return;
        if(world.recreating) return;

        const canvas = this.$("canvas");
        
        const checkWebgl = document.getElementById('webgl');
        if(checkWebgl.checked) {
          const gl = canvas.getContext('webgl');
          if(gl && checkWebgl.checked) {
            this.render_gl(gl, canvas, world, colorFunc);
            return;
          }
        }

        // if(!gl) { // WebGL が使えない
        //   checkWebgl.checked = "";
        //   checkWebgl.disabled = "disabled";
        // }

        // this.buffer2 に offset を無視した画像を作る

        // まず尾を引かせる背景処理
        if(!this.buffer2)
          this.buffer2 = canvas.cloneNode();
        if(this.buffer2.width != canvas.width ||
           this.buffer2.height != canvas.height) {
            this.buffer2.width = canvas.width;
            this.buffer2.height = canvas.height;
        }
        const g2 = this.buffer2.getContext('2d');
        g2.setTransform(1, 0, 0, 1, 0, 0);

        let t = this.state.tail;
        if(t > 50) {
          this.tailCount = (this.tailCount || 0) + 50/t;
          t = 50;
        } else {
          this.tailCount = 1;
        }

        if(this.tailCount >= 1) {
          // 背景塗りつぶし
          let style = '#000000';  // 真っ黒
          if( t > 0 ) {  
            // 尾を引かせるときは alpha を指定する
            style += ('0' + ((255 / (1.0 + 1.0 * t)) | 0).toString(16)).substr(-2);
          }
          g2.fillStyle = style;
          g2.globalCompositeOperation = "source-over"
          g2.fillRect(0, 0, this.buffer2.width, this.buffer2.height);

          g2.fillStyle = "#010101";
          g2.globalCompositeOperation = "difference"
          g2.fillRect(0, 0, this.buffer2.width, this.buffer2.height);

          this.tailCount -= 1;
        }

        // WebGL を使わない描画
        g2.globalCompositeOperation = "source-over"
        this.render_2d(g2, world, colorFunc);
        g2.setTransform(1, 0, 0, 1, 0, 0);

        const g = canvas.getContext('2d');
        this.drawImageWithOffset(g, this.buffer2);
      },

      render_gl(gl, canvas, world, colorFunc) {

        if(!this.rendererGL) {
          this.rendererGL = new this.ParticleRendereGL(gl);

          // 32px x 32px circle
          this.rendererGL.loadTexture(`data:image/png;base64,
            iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABJklEQVRYw82X
            oW4CQRRFz5sGV9O0+PYLUFiyGsVH9GtQWJJqPqFqFbYGvgB8SxBULSUXwSOp
            IM22XebtsZPZeyc77819Rk0k3QNDYAD0gCfgzpe3wApYAnPg1cw2NIGkvqSp
            pJ3qs/M9/f8IdyWNJVX6O5V/o/tb8UJSqeYoJRV1xUeSFmqehaRRnZNfQ/y7
            ieKnf17q+pQX74RfllyML5ValdFAdS7R5B6egQ756Lgm5h1uDdySl0/gMXl7
            zS2Oaw6T9/YoBskflih6JukdeAgy8GGSvoCbIAOHRDDJw0QU2+RJJopV8hgV
            xTJ5hotiHt+KPb3OAk4/M7PNuQxfgH1G8b1rnp5jM3sDJhkNTFyzRZEsPJS2
            Ipa3YjBpxWiWczi16PH8CAvfPn83UHV5AAAAAElFTkSuQmCC`);
        }

        let tail = this.state.tail;
        if(!this.frameBuffer1) {
          this.frameBuffer1 = new util.glFrameBuffer(gl, this.state.size, this.state.size, false);
          this.frameBuffer2A = new util.glFrameBuffer(gl, this.state.size, this.state.size, false);
          this.frameBuffer2B = new util.glFrameBuffer(gl, this.state.size, this.state.size, false);
          
          const fsrcTail = `
            precision mediump float;
            uniform sampler2D u_texture;
            uniform sampler2D u_texture2;
            uniform float u_tail;
            uniform int u_time;
            uniform vec2 u_size;
            void main(void){
              vec2 uv = gl_FragCoord.xy / u_size;
              vec4 now = texture2D(u_texture, uv);
              vec4 last = texture2D(u_texture2, uv);
              vec4 c;
              float u_tail1 = u_tail + 1.0;
              float comp = u_tail1 / 255.0;
              // 割合で減らなくなったら 間隔をあけて減らす
              c.r = last.r * u_tail / u_tail1; 
              if((last.r - c.r) * 255.0 < 1.0)
                if((u_time - u_time/(int(comp/last.r))*(int(comp/last.r))) == 0) c.r -= 1.0/256.0;
              c.g = last.g * u_tail / u_tail1;
              if((last.g - c.g) * 255.0 < 1.0) 
                if((u_time - u_time/(int(comp/last.g))*(int(comp/last.g))) == 0) c.g -= 1.0/256.0;
              c.b = last.b * u_tail / u_tail1;
              if((last.b - c.b) * 255.0 < 1.0) 
                if((u_time - u_time/(int(comp/last.b))*(int(comp/last.b))) == 0) c.b -= 1.0/256.0;
              c.a = 1.0;
              gl_FragColor = max(c, now);
            }
          `;
          this.frameRendererTail = new util.glTextureRenderer(gl, fsrcTail, 
            ["u_size", "u_tail", "u_time", "u_texture2"]);
          
          const fsrcOffset = `
            precision mediump float;
            uniform sampler2D u_texture;
            uniform vec2 u_size;
            uniform vec2 u_offset;
            void main(void){
              // ここで uv から gl_FragColor を求める
              float size = min(u_size.x, u_size.y);
              vec2 of = (u_size - size) / 2.0;
              vec2 uv = (gl_FragCoord.xy - of) / size + u_offset;
              uv.x -= floor(uv.x);
              uv.y -= floor(uv.y);
              gl_FragColor = texture2D(u_texture, uv);
              vec2 test = gl_FragCoord.xy - of;
              if(test.x < 0.0 || test.y < 0.0) gl_FragColor.rgb /= 2.0;
              test = gl_FragCoord.xy -size - of;
              if(test.x > 0.0 || test.y > 0.0) gl_FragColor.rgb /= 2.0;
            }
          `;
          this.frameRendererOffset = new util.glTextureRenderer(gl, fsrcOffset, 
            ["u_size", "u_offset"]);
          
          tail = 0;
          this.counter = 1;
        }
        if(this.frameBuffer1.width != this.state.size) {
          this.frameBuffer1.resize(this.state.size, this.state.size)
          this.frameBuffer2A.resize(this.state.size, this.state.size)
          this.frameBuffer2B.resize(this.state.size, this.state.size)
          tail = 0;
          this.counter = 1;
        }

        this.rendererGL.render(
          0, this.state.size, this.state.size,
          world, colorFunc, this.calcParticleSize(),
          this.frameBuffer1
        );

        let src = this.counter % 2 == 0 ? this.frameBuffer2A : this.frameBuffer2B;
        let dest = this.counter % 2 == 0 ? this.frameBuffer2B : this.frameBuffer2A;

        this.frameRendererTail.render(1, this.frameBuffer1.texture, (gl, program)=> {
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          gl.viewport(0,0, this.state.size, this.state.size);
          program.u_tail.f(tail);
          program.u_size.f(this.state.size, this.state.size);
          program.u_time.i(this.count);
          program.u_texture2.i(2);
          gl.activeTexture(gl.TEXTURE2);
          gl.bindTexture(gl.TEXTURE_2D, src.texture);
        }, dest);

        this.frameRendererOffset.render(3, dest.texture, (gl, program)=> {
          gl.disable(gl.BLEND);
          gl.disable(gl.DEPTH_TEST);
          gl.viewport(0,0,canvas.width,canvas.height);
          program.u_size.f(canvas.width, canvas.height);
          program.u_offset.f(this.state.offsetX, -this.state.offsetY);
        });

        this.counter += 1;
      }
    }
  </script>
</particles-display>
