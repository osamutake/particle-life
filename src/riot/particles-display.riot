<!-----------------------------------------------------------------

  粒子を表示するコントロール
  css は bulma を使用

  props = {
    width
    height
  }

  state = {
    repelX: 0,  // 外から参照されることを想定
    repelY: 0,  // 外から参照されることを想定
    offsetX: 0,   // 内部でのみ使われる
    offsetY: 0,   // 内部でのみ使われる
    tail: 0       // 内部でのみ使われる
  }

----------------------------------------------------------------->

<particles-display>
  <canvas width={props.width} height={props.height}></canvas>

  <style type="scss">
    :host {
      line-height: 1;

      > div {
        margin: 0px;
      }
      canvas {
        touch-action: none;
        margin: 0px;
        max-width: 100vw;
      }
      @media screen and (max-width: 450px) {
        canvas {
          margin-left: -0.75rem;
          margin-right: -0.75rem;
        }
      }
      @media screen and (min-width: 1000px) {
        canvas {
          min-width: 600px;
        }
      }
    }
  </style>

  <script>
    export default {

      onMounted() {

        this.state = {
          repelX: NaN,
          repelY: NaN,
          offsetX: 0,
          offsetY: 0,
          tail: 0
        }

        this.initializeRequired = true;

        let canvas = this.$('canvas');

        // ワーキングキャンバスを作成
        this.buffer = canvas.cloneNode();   // WebGL で使う
        this.buffer2 = canvas.cloneNode();  // 尾を付ける処理の前
        this.buffer3 = canvas.cloneNode();  // スクロール処理の前

        // マウス座標から x, y 座標に直す
        const mouse2xy = (mouseX, mouseY) => {
          return [
            mouseX / canvas.clientWidth  - 0.5 + this.state.offsetX, 
            mouseY / canvas.clientHeight - 0.5 + this.state.offsetY
          ];
        };
          
        let canvasTapCount = 0;
        let mouseDoubleDown = false;
        this.defineDragBehavior( canvas, {
          down: (e, x, y) => {
          	if( canvasTapCount == 0 ) {
            	// シングルタップ
          		canvasTapCount++;
          		setTimeout( () =>{ canvasTapCount = 0; }, 350 ) ;

          	} else {
            	// ダブルタップ
          		canvasTapCount = 0 ;

              mouseDoubleDown = true;
              [this.state.repelX, this.state.repelY] = mouse2xy(x, y)
          	}
          },
          move: (e, mouseDown, newX, newY, oldX, oldY) => {
            if(mouseDown) {
              if(!mouseDoubleDown) {
                // スクロールする
                const [dx, dy] = [newX - oldX, newY - oldY];
                this.state.offsetX -= dx / canvas.width; 
                this.state.offsetX -= Math.round(this.state.offsetX);
                this.state.offsetY -= dy / canvas.height; 
                this.state.offsetY -= Math.round(this.state.offsetY);
                this.render();
              } else {
                [this.state.repelX, this.state.repelY] = mouse2xy(newX, newY)
              }
            }
          },
          up: (e, x, y) => {
            mouseDoubleDown = false;
            [this.state.repelX, this.state.repelY] = [NaN, NaN]
          }
        });

      },

      onUpdated(props, state) {
        const screens = {
          XS: 400, S: 600, M: 900, L: 1200, XL: 1500
        }

        let size = screens[this.state.screen]
        let canvas = this.$('canvas');
        if(canvas && (canvas.width != size)) {
          [canvas.width, canvas.height] =
          [this.buffer.width, this.buffer.height] =
          [this.buffer2.width, this.buffer2.height] =
          [this.buffer3.width, this.buffer3.height] = [size, size];
          this.initializeRequired = true;
        }

        this.render();
      },


      // WebGL が使えない場合の通常の描画

      render_2d(g, world, colorFunc) {
        g.setTransform(1, 0, 0, 1, 0, 0);

        let canvas = this.$("canvas");
        g.scale(canvas.width, canvas.height);
        g.translate(0.5, 0.5);

        // 背景塗りつぶし
        let style = '#000000';  // 真っ黒
        g.fillStyle = style;
        g.fillRect(-0.5, -0.5, 1, 1);
        
        // パレットを作成
        const n = world.nspecies;
        const palette = [...Array(n)].map((_, i) => colorFunc(i/n));

        // 粒子の描画
        const r = world.particle_radius;
        world.particles.forEach( (sp, x, y) => {
          g.beginPath();
          g.fillStyle = palette[sp];
          g.arc(x, y, r, 0, 2 * Math.PI);
          g.fill();
        });
      },


      // WebGL の初期化

      initialize_gl(gl) {
        /*=========================Shaders========================*/

        // vertex shader source code
        var vshaderSrc = `
          attribute vec4 a_position;
          attribute vec4 a_color;
          varying vec4 v_color;
          void main(void) {
            gl_Position = a_position;
            gl_PointSize = 2.5;
            v_color = a_color;
          }
        `;

        // Create a vertex shader object
        var vshader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vshader, vshaderSrc);
        gl.compileShader(vshader);

        var fshaderSrc = `
          precision mediump float;
          varying vec4 v_color;
          void main(void) {
            gl_FragColor = v_color;
          }
        `;

        var fshader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fshader, fshaderSrc);
        gl.compileShader(fshader);
         
        var shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vshader); 
        gl.attachShader(shaderProgram, fshader);
        gl.linkProgram(shaderProgram);
        gl.useProgram(shaderProgram);
        gl.program = shaderProgram;

        let vertex_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

        /*======== Associating shaders to buffer objects ========*/

        let size = 2; // vertices.BYTES_PER_ELEMENT

        let a_position = gl.getAttribLocation(gl.program, 'a_position');
        gl.vertexAttribPointer(a_position, 2, gl.SHORT, true, size * 5, 0);
        gl.enableVertexAttribArray(a_position);

        let a_color = gl.getAttribLocation(gl.program, 'a_color');
        gl.vertexAttribPointer(a_color, 3, gl.SHORT, true, size * 5, size * 2);
        gl.enableVertexAttribArray(a_color);

        // Set the view port
        const canvas = this.$("canvas");
        gl.viewport(0, 0, canvas.width, canvas.height);
      },


      // WebGL による描画

      render_gl(gl, world, colorFunc) {

        // 一旦消去
        gl.clearColor(0, 0, 0, 1);  // 背景色
        gl.disable(gl.DEPTH_TEST);
        gl.clear(gl.COLOR_BUFFER_BIT);

        let palette = [...Array(world.nspecies)].map((_, i) => {
            const c = colorFunc(i/world.nspecies);
            return [parseInt(c.slice(1, 3), 16), parseInt(c.slice(3, 5), 16), parseInt(c.slice(5, 7), 16)]
          }
        );

        gl.bufferData(gl.ARRAY_BUFFER, world.particles.vertices(palette), gl.DYNAMIC_DRAW);
        gl.drawArrays(gl.POINTS, 0, world.nparticles);
      },


      // source を g のスクロール位置に描画する

      drawImageWithOffset(g, source) {
        const [w, h] = [source.width, source.height];
        const [dx, dy] = [-this.state.offsetX * w, -this.state.offsetY * h]

        const region = (sx, sy) => {  // ４象限を計算する
          const x1 = (w - dx) % w; const y1 = (h - dy) % h; 
          const x2 = (dx + w) % w; const y2 = (dy + h) % h; 
          return [
            Math.min(x1, sx ? 0 : w),  Math.min(y1, sy ? 0 : h),
            Math.abs(x1-(sx ? 0 : w)), Math.abs(y1-(sy ? 0 : h)), 
            Math.min(x2, sx ? w : 0),  Math.min(y2, sy ? h : 0),
            Math.abs(x1-(sx ? 0 : w)), Math.abs(y1-(sy ? 0 : h)) ];
        }
        g.drawImage(source, ...region(0, 0));
        g.drawImage(source, ...region(1, 0));
        g.drawImage(source, ...region(0, 1));
        g.drawImage(source, ...region(1, 1));
      },

      // 描画する
      render() {

        world = this.world && this.world();
        colorFunc = this.colorFunc && this.colorFunc();
        if(!world || !colorFunc) return;


        // this.buffer2 に offset を無視した画像を作る

        let gl = this.buffer.getContext('webgl'); 
        let g2 = this.buffer2.getContext('2d');
        if(!gl) {
          // WebGL が使えなければ通常の描画
          this.render_2d(g2, world, colorFunc);
          this.initializeRequired = false;
        } else {
          if(this.initializeRequired) {
            this.initialize_gl(gl);
            this.initializeRequired = false;
          }
          this.render_gl(gl, world, colorFunc);
          g2.drawImage(this.buffer, 0, 0);
        }

        const canvas = this.$("canvas");
        const g = canvas.getContext('2d');

        // 尾を引かせる処理
        const g3 = this.buffer3.getContext('2d');

        g3.globalAlpha = 1;
        t = this.state.tail;
        if(t > 50) {
          this.tailCount = (this.tailCount || 0) + 50/t;
          t = 50;
        } else {
          this.tailCount = 1;
        }

        if(this.tailCount >= 1) {
          // 背景塗りつぶし
          let style = '#000000';  // 真っ黒
          if( t > 0 ) {  
            // 尾を引かせるときは alpha を指定する
            style += ('0' + ((255 / (1.0 + 1.0 * t)) | 0).toString(16)).substr(-2);
          }
          g3.fillStyle = style;
          g3.globalCompositeOperation = "source-over"
          g3.fillRect(0, 0, canvas.width, canvas.height);

          g3.fillStyle = "#010101";
          g3.globalCompositeOperation = "difference"
          g3.fillRect(0, 0, canvas.width, canvas.height);

          this.tailCount -= 1;
        }

        g3.globalCompositeOperation = "screen"
        g3.drawImage(this.buffer2, 0, 0);

        this.drawImageWithOffset(g, this.buffer3);

      }
    }
  </script>
</particles-display>
